<!DOCTYPE html>
<!-- saved from url=(0103)https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml -->
<html class=" js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="1355477" data-user-uuid="7f975f1c-dea3-4e80-99fb-9a28ca51d787" data-username="henryxiang" data-account-type="Paid" data-activated-trial-date="02/05/2017" data-archive="9781284056242" data-publishers="Jones &amp; Bartlett Learning" data-htmlfile-name="04_Contents.xhtml" data-epub-title="Essentials of Discrete Mathematics, 3rd Edition" data-debug="0" data-testing="0" style=""><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9781284056242"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/cool-2.1.15.min.js"></script><script type="text/javascript" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/510f1a6865"></script><script id="twitter-wjs" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/widgets.js"></script><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/nr-1118.min.js"></script><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/1732687426968531" async=""></script><script async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fbevents.js"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f.txt"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f.txt"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/bat.js"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f.txt"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/insight.min.js"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f.txt"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/linkid.js"></script><script async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/gtm.js"></script><script async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/analytics.js"></script><script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(e,n,t){function r(t){if(!n[t]){var o=n[t]={exports:{}};e[t][0].call(o.exports,function(n){var o=e[t][1][n];return r(o||n)},o,o.exports)}return n[t].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<t.length;o++)r(t[o]);return r}({1:[function(e,n,t){function r(){}function o(e,n,t){return function(){return i(e,[c.now()].concat(u(arguments)),n?null:this,t),n?void 0:this}}var i=e("handle"),a=e(3),u=e(4),f=e("ee").get("tracer"),c=e("loader"),s=NREUM;"undefined"==typeof window.newrelic&&(newrelic=s);var p=["setPageViewName","setCustomAttribute","setErrorHandler","finished","addToTrace","inlineHit","addRelease"],d="api-",l=d+"ixn-";a(p,function(e,n){s[n]=o(d+n,!0,"api")}),s.addPageAction=o(d+"addPageAction",!0),s.setCurrentRouteName=o(d+"routeName",!0),n.exports=newrelic,s.interaction=function(){return(new r).get()};var m=r.prototype={createTracer:function(e,n){var t={},r=this,o="function"==typeof n;return i(l+"tracer",[c.now(),e,t],r),function(){if(f.emit((o?"":"no-")+"fn-start",[c.now(),r,o],t),o)try{return n.apply(this,arguments)}catch(e){throw f.emit("fn-err",[arguments,this,e],t),e}finally{f.emit("fn-end",[c.now()],t)}}}};a("actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","),function(e,n){m[n]=o(l+n)}),newrelic.noticeError=function(e,n){"string"==typeof e&&(e=new Error(e)),i("err",[e,c.now(),!1,n])}},{}],2:[function(e,n,t){function r(e,n){if(!o)return!1;if(e!==o)return!1;if(!n)return!0;if(!i)return!1;for(var t=i.split("."),r=n.split("."),a=0;a<r.length;a++)if(r[a]!==t[a])return!1;return!0}var o=null,i=null,a=/Version\/(\S+)\s+Safari/;if(navigator.userAgent){var u=navigator.userAgent,f=u.match(a);f&&u.indexOf("Chrome")===-1&&u.indexOf("Chromium")===-1&&(o="Safari",i=f[1])}n.exports={agent:o,version:i,match:r}},{}],3:[function(e,n,t){function r(e,n){var t=[],r="",i=0;for(r in e)o.call(e,r)&&(t[i]=n(r,e[r]),i+=1);return t}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],4:[function(e,n,t){function r(e,n,t){n||(n=0),"undefined"==typeof t&&(t=e?e.length:0);for(var r=-1,o=t-n||0,i=Array(o<0?0:o);++r<o;)i[r]=e[n+r];return i}n.exports=r},{}],5:[function(e,n,t){n.exports={exists:"undefined"!=typeof window.performance&&window.performance.timing&&"undefined"!=typeof window.performance.timing.navigationStart}},{}],ee:[function(e,n,t){function r(){}function o(e){function n(e){return e&&e instanceof r?e:e?f(e,u,i):i()}function t(t,r,o,i){if(!d.aborted||i){e&&e(t,r,o);for(var a=n(o),u=v(t),f=u.length,c=0;c<f;c++)u[c].apply(a,r);var p=s[y[t]];return p&&p.push([b,t,r,a]),a}}function l(e,n){h[e]=v(e).concat(n)}function m(e,n){var t=h[e];if(t)for(var r=0;r<t.length;r++)t[r]===n&&t.splice(r,1)}function v(e){return h[e]||[]}function g(e){return p[e]=p[e]||o(t)}function w(e,n){c(e,function(e,t){n=n||"feature",y[t]=n,n in s||(s[n]=[])})}var h={},y={},b={on:l,addEventListener:l,removeEventListener:m,emit:t,get:g,listeners:v,context:n,buffer:w,abort:a,aborted:!1};return b}function i(){return new r}function a(){(s.api||s.feature)&&(d.aborted=!0,s=d.backlog={})}var u="nr@context",f=e("gos"),c=e(3),s={},p={},d=n.exports=o();d.backlog=s},{}],gos:[function(e,n,t){function r(e,n,t){if(o.call(e,n))return e[n];var r=t();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,n,{value:r,writable:!0,enumerable:!1}),r}catch(i){}return e[n]=r,r}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],handle:[function(e,n,t){function r(e,n,t,r){o.buffer([e],r),o.emit(e,n,t)}var o=e("ee").get("handle");n.exports=r,r.ee=o},{}],id:[function(e,n,t){function r(e){var n=typeof e;return!e||"object"!==n&&"function"!==n?-1:e===window?0:a(e,i,function(){return o++})}var o=1,i="nr@id",a=e("gos");n.exports=r},{}],loader:[function(e,n,t){function r(){if(!E++){var e=x.info=NREUM.info,n=l.getElementsByTagName("script")[0];if(setTimeout(s.abort,3e4),!(e&&e.licenseKey&&e.applicationID&&n))return s.abort();c(y,function(n,t){e[n]||(e[n]=t)}),f("mark",["onload",a()+x.offset],null,"api");var t=l.createElement("script");t.src="https://"+e.agent,n.parentNode.insertBefore(t,n)}}function o(){"complete"===l.readyState&&i()}function i(){f("mark",["domContent",a()+x.offset],null,"api")}function a(){return O.exists&&performance.now?Math.round(performance.now()):(u=Math.max((new Date).getTime(),u))-x.offset}var u=(new Date).getTime(),f=e("handle"),c=e(3),s=e("ee"),p=e(2),d=window,l=d.document,m="addEventListener",v="attachEvent",g=d.XMLHttpRequest,w=g&&g.prototype;NREUM.o={ST:setTimeout,SI:d.setImmediate,CT:clearTimeout,XHR:g,REQ:d.Request,EV:d.Event,PR:d.Promise,MO:d.MutationObserver};var h=""+location,y={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-1118.min.js"},b=g&&w&&w[m]&&!/CriOS/.test(navigator.userAgent),x=n.exports={offset:u,now:a,origin:h,features:{},xhrWrappable:b,userAgent:p};e(1),l[m]?(l[m]("DOMContentLoaded",i,!1),d[m]("load",r,!1)):(l[v]("onreadystatechange",o),d[v]("onload",r)),f("mark",["firstbyte",u],null,"api");var E=0,O=e(5)},{}]},{},["loader"]);</script><link rel="apple-touch-icon" href="https://learning.oreilly.com/static/images/apple-touch-icon.0c29511d2d72.png"><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/css" rel="stylesheet" type="text/css"><title>Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition</title><link rel="stylesheet" href="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/1f82858304ba.css" type="text/css"><link rel="stylesheet" type="text/css" href="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/annotator.e3b0c44298fc.css"><link rel="stylesheet" href="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/font-awesome.min.css"><style type="text/css" title="ibis-book">@font-face{font-family:"Charter";font-style:normal;font-weight:normal;src:url(../fonts/charter_bt_roman.ttf)}@font-face{font-family:"Charter";font-style:italic;font-weight:normal;src:url(../fonts/Charter_Italic_BT.ttf)}@font-face{font-family:"Charter";font-style:normal;font-weight:bold;src:url(../fonts/CharterBT-Bold.ttf)}@font-face{font-family:"Charter";font-style:italic;font-weight:normal;src:url(../fonts/CharterBT-Italic.ttf)}@font-face{font-family:"BulmerMTSTD-Display";font-style:normal;font-weight:normal;src:url(../fonts/BulmerMTSTD-Display.ttf)}@font-face{font-family:"BulmerMTSTD-Display";font-style:italic;font-weight:normal;src:url(../fonts/BulmerMTSTD-Italic.ttf)}@font-face{font-family:"BulmerMT-Regular";font-style:normal;font-weight:normal;src:url(../fonts/BulmerMT-Regular.ttf)}@font-face{font-family:"Cour";font-style:normal;font-weight:normal;src:url(../fonts/cour.ttf)}@font-face{font-family:"MathDesign-CH-Regular";font-style:normal;font-weight:normal;src:url(../fonts/MathDesign-CH-Regular-Symbol-10.ttf)}@font-face{font-family:"MathDesign-CH-Regular1";font-style:normal;font-weight:normal;src:url(../fonts/MathDesign-CH-Regular-MathDesignSymbolB-10.ttf)}@font-face{font-family:"MathDesign-CH-Regular-T1";font-style:normal;font-weight:normal;src:url(../fonts/MathDesign-CH-Regular-T1-10.ttf)}@font-face{font-family:"MathDesign-CH-Regularb";font-style:normal;font-weight:normal;src:url(../fonts/MathDesign-CH-Regular-MathDesignSymbolA-10.ttf)}@font-face{font-family:"opens";font-style:normal;font-weight:normal;src:url(../fonts/opensymbol.ttf)}#sbo-rt-content div{font-family:"Charter","MathDesign-CH-Regular","MathDesign-CH-Regular1";margin:1em;line-height:1.1em}#sbo-rt-content a{text-decoration:none}#sbo-rt-content .box{margin-top:1em;margin-bottom:1em;text-indent:0;margin-left:0;margin-right:0;background-color:#ebebeb;padding:.2em;color:black}#sbo-rt-content .cover{text-align:center;margin-top:0;margin-bottom:0;text-indent:0;margin-left:0;margin-right:0}#sbo-rt-content span.blue{color:#23aeef}#sbo-rt-content img.blo{width:auto;height:100%}#sbo-rt-content img{max-width:100%;max-height:100%;vertical-align:middle}#sbo-rt-content sup{vertical-align:.55em;font-size:.6em;line-height:0}#sbo-rt-content sub{vertical-align:-.4em;font-size:.6em;line-height:0}#sbo-rt-content div.cap{text-indent:0;margin-left:0;margin-top:0;margin-bottom:0;page-break-inside:avoid}#sbo-rt-content .border{margin-top:2em;margin-bottom:.1em;border-bottom:1px solid #00aeef;margin-left:2em;margin-right:2em}#sbo-rt-content .border1{margin-top:.3em;margin-bottom:.1em;border-bottom:1px solid #00aeef;margin-left:5em;margin-right:5em}#sbo-rt-content .title{margin-top:1em;margin-bottom:0;text-align:center;margin-left:0;text-indent:0;font-size:1.5em;line-height:1.2em;font-family:"BulmerMTSTD-Display"}#sbo-rt-content span.tt{font-size:1.2em}#sbo-rt-content .edi{margin-top:1em;margin-bottom:0;text-align:center;margin-left:0;text-indent:0;font-size:1.3em;line-height:0;font-family:"BulmerMTSTD-Display"}#sbo-rt-content .aut{margin-top:1em;margin-bottom:0;font-size:1.2em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em;font-family:"BulmerMT-Regular"}#sbo-rt-content .auta{margin-top:0;margin-bottom:0;font-size:1em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em;font-family:"BulmerMT-Regular"}#sbo-rt-content .pub{margin-top:1em;margin-bottom:0;text-align:center;margin-left:0;text-indent:0}#sbo-rt-content .pub1{margin-top:1em;margin-bottom:0;text-align:center;margin-left:0;text-indent:0}#sbo-rt-content .copyt{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .copy{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .copy1{margin-top:1em;margin-bottom:0;font-size:.75em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .copya{margin-top:.5em;margin-bottom:0;font-size:.75em;text-align:justify;margin-left:0;text-indent:0}#sbo-rt-content .copy2{margin-top:0;margin-bottom:0;text-align:left;margin-left:1em;font-size:.75em;text-indent:-1em}#sbo-rt-content .copy3{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:1.7em;text-indent:0}#sbo-rt-content .copy4{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:0;text-indent:.7em}#sbo-rt-content .copy5{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .copy6{margin-top:0;margin-bottom:0;font-size:.75em;text-align:right;margin-left:0;margin-right:4em;text-indent:0}#sbo-rt-content .toc{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0;font-weight:bold}#sbo-rt-content .toc2{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:2.45em;text-indent:-2.45em}#sbo-rt-content .toc2a{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .toc3{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:5.85em;text-indent:-3.4em}#sbo-rt-content .toct{margin-top:1.3em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .toc1{margin-top:1.5em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .toc1c{margin-top:1.3em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .indent{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:1.8em}#sbo-rt-content .indenta{margin-top:.1em;margin-bottom:1em;font-size:.85em;text-align:justify;margin-left:0;text-indent:1.8em}#sbo-rt-content .indentt{margin-top:.9em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:1.8em}#sbo-rt-content .indent-1{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:1.8em}#sbo-rt-content .indent1{margin-top:.7em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:1.8em}#sbo-rt-content .indent1s{margin-top:.7em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:2.8em}#sbo-rt-content .figcaption{margin-top:0;margin-bottom:1em;font-size:.85em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .figcaption1{margin-top:0;margin-bottom:1em;font-size:.85em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .figcaptionj{margin-top:0;margin-bottom:1em;font-size:.85em;text-align:justify;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .tabcaption{margin-top:0;margin-bottom:1em;font-size:.85em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .tabcaption1a{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content p.h1{font-weight:bold;margin-top:1.3em;margin-bottom:.6em;font-size:1.2em;text-align:left;margin-left:0;text-indent:0;color:#23aeef}#sbo-rt-content p.h2{font-weight:bold;margin-top:1.1em;margin-bottom:.6em;font-size:.95em;text-align:left;margin-left:0;text-indent:0;color:#23aeef}#sbo-rt-content .h3{margin-top:.5em;margin-bottom:2em;font-size:.9em;text-align:center;margin-left:0;text-indent:0;font-weight:bold}#sbo-rt-content .numlist{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.7em;text-indent:-2em}#sbo-rt-content .numlistm{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.7em;text-indent:-2.6em}#sbo-rt-content .numlistdd{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:-2em}#sbo-rt-content .numlistd{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:-2.5em}#sbo-rt-content .numlistds{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-3em}#sbo-rt-content .numlists{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:-2.5em}#sbo-rt-content .numlist2n{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2em}#sbo-rt-content .numlist1s{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:-2em}#sbo-rt-content .numlist2{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:5em;text-indent:-2em}#sbo-rt-content .numlist2t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:5em;text-indent:-2em}#sbo-rt-content .numlist1at{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:-4.3em}#sbo-rt-content .numlistparah{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:-1.5em}#sbo-rt-content .numlistpara1{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.7em;text-indent:0}#sbo-rt-content .numlistpara1s{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:0}#sbo-rt-content .numlistpara1c{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;text-indent:0}#sbo-rt-content .loweralpha{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:1.75em;text-indent:-1.75em}#sbo-rt-content .loweralphat{margin-top:.7em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:1.75em;text-indent:-1.75em}#sbo-rt-content .loweralpha1{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.5em;text-indent:-2.5em}#sbo-rt-content .loweralpha1t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.5em;text-indent:-2.5em}#sbo-rt-content .loweralpha1_c5{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:6em;text-indent:-2.5em}#sbo-rt-content .loweralpha1_c51{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.6em;text-indent:-2.5em}#sbo-rt-content .loweralpha1t_c5{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:6em;text-indent:-2.5em}#sbo-rt-content .loweralpha2{margin-top:.2em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3.5em;text-indent:-2.5em}#sbo-rt-content .loweralpha2t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3.5em;text-indent:-2.5em}#sbo-rt-content .loweralpha2a{margin-top:.2em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.5em;text-indent:-2.5em}#sbo-rt-content .loweralpha2at{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.5em;text-indent:-2.5em}#sbo-rt-content .loweralphapara2{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.4em;margin-right:1em;text-indent:0}#sbo-rt-content .loweralphapara2n{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.5em;margin-right:1em;text-indent:0}#sbo-rt-content .loweralphapara2a{margin-top:.1em;margin-bottom:.5em;font-size:.85em;text-align:justify;margin-left:4.4em;margin-right:1em;text-indent:0}#sbo-rt-content .loweralphapara2b{margin-top:.5em;margin-bottom:.5em;font-size:.85em;text-align:justify;margin-left:4em;margin-right:1em;text-indent:0}#sbo-rt-content .loweralphapara2t{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.4em;margin-right:1em;text-indent:0}#sbo-rt-content .loweralphapara2ta{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.6em;margin-right:0;text-indent:0}#sbo-rt-content .loweralpha1r2{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.15em;text-indent:-2.5em}#sbo-rt-content .loweralpha1r3{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:-2.5em}#sbo-rt-content .noindent{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:0}#sbo-rt-content .noindentt{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:0}#sbo-rt-content .noindentta{margin-top:2em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:0}#sbo-rt-content .noindent1{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:.2em;margin-right:.2em;text-indent:0}#sbo-rt-content .noindent1t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:.2em;margin-right:.2em;text-indent:0}#sbo-rt-content .hang1t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.7em;text-indent:-.8em}#sbo-rt-content .hang1{margin-top:.2em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:-.5em}#sbo-rt-content .imagel{margin-top:1em;margin-bottom:1em;text-align:left;margin-left:2.75em;text-indent:0}#sbo-rt-content .imagel1{margin-top:0;margin-bottom:0;text-align:left;margin-left:2.75em;text-indent:0}#sbo-rt-content .image{margin-top:1em;margin-bottom:1em;font-size:.85em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .image1{margin-top:1em;margin-bottom:1em;text-align:center;margin-left:0;text-indent:0}#sbo-rt-content .chaptitle{font-weight:bold;margin-top:.5em;margin-bottom:3em;font-size:2.5em;text-align:left;margin-left:0;color:#23aeef;text-indent:0;line-height:1.2em}#sbo-rt-content .fm-title{font-weight:bold;margin-top:1em;margin-bottom:1.5em;font-size:1.5em;text-align:center;margin-left:0;line-height:1em;color:#23aeef;text-indent:0}#sbo-rt-content .chapnum{font-weight:bold;margin-top:3em;margin-bottom:0;font-size:1.8em;text-align:left;margin-left:0;color:#23aeef;text-indent:0}#sbo-rt-content .bull1ts{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:3.3em;text-indent:-1.9em}#sbo-rt-content .bull1s{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:left;margin-right:0;margin-left:3.3em;text-indent:-1.9em}#sbo-rt-content .bull1t{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:2.9em;text-indent:-1.9em}#sbo-rt-content .bull1{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:left;margin-right:0;margin-left:2.9em;text-indent:-1.9em}#sbo-rt-content .bull2t{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:5em;text-indent:-1.7em}#sbo-rt-content .bull2{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:5em;text-indent:-1.7em}#sbo-rt-content .bullpara2{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:left;margin-right:0;margin-left:4.2em;text-indent:0}#sbo-rt-content .bullpara2a{margin-top:0;margin-bottom:0;font-size:.85em;text-align:left;margin-right:0;margin-left:4.2em;text-indent:0}#sbo-rt-content .ref{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2.5em}#sbo-rt-content .ref1{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-3em}#sbo-rt-content .footnote{margin-top:.1em;margin-bottom:0;font-size:.75em;text-align:justify;text-indent:0}#sbo-rt-content .index{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:3.9em;text-indent:-3.9em}#sbo-rt-content .index1{margin-top:0;margin-bottom:0;font-size:.75em;text-align:left;margin-left:4.2em;text-indent:-2em}#sbo-rt-content .ind-no{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:0;text-indent:0}#sbo-rt-content .table{margin-top:1em;margin-bottom:1em;text-align:left;margin-left:1em;text-indent:0;border-collapse:collapse}#sbo-rt-content .tabley{margin-top:.5em;margin-bottom:.5em;margin-left:4.6em;border-collapse:collapse}#sbo-rt-content .table1{margin-top:1em;margin-bottom:1em;font-size:.85em;text-align:center;text-indent:0;border-collapse:collapse}#sbo-rt-content .tablec{margin-top:1em;margin-bottom:1em;font-size:.85em;text-indent:0;border-collapse:collapse}#sbo-rt-content .table1a{margin-top:1em;margin-bottom:1em;margin-left:0;margin-right:0;text-indent:0;border-collapse:collapse}#sbo-rt-content .quote{font-size:.85em;margin-top:.5em;margin-bottom:.8em;text-align:justify;margin-left:4em;margin-right:0;text-indent:0}#sbo-rt-content .blockquotetb{font-size:.85em;margin-top:0;margin-bottom:0;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquotet{font-size:.85em;margin-top:.5em;margin-bottom:0;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquote{font-size:.85em;margin-top:.5em;margin-bottom:.8em;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquote1a{font-size:.7em;margin-top:.5em;margin-bottom:.8em;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquotes{font-size:.85em;margin-top:0;margin-bottom:.8em;text-align:justify;margin-left:3.6em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquotesb{font-size:.85em;margin-top:0;margin-bottom:0;text-align:justify;margin-left:3.6em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquotesa{font-size:.85em;margin-top:.5em;margin-bottom:0;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquotea{font-size:.85em;margin-top:.5em;margin-bottom:0;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquote1{margin-top:.6em;margin-bottom:.6em;font-size:.85em;text-align:justify;margin-left:5.8em;margin-right:1em;text-indent:0}#sbo-rt-content .blockquote3{font-size:.85em;margin-top:.5em;margin-bottom:.5em;text-align:justify;margin-left:7em;margin-right:1em;text-indent:0}#sbo-rt-content .block{margin-top:1em;margin-bottom:1em;text-align:justify;margin-left:1em;margin-right:1em;text-indent:0}#sbo-rt-content .rm{margin-top:0;margin-bottom:0;font-size:.85em;text-align:right;margin-left:0;margin-right:.5em;text-indent:0}#sbo-rt-content .right{margin-top:0;margin-bottom:0;font-size:.85em;text-align:right;margin-left:0;text-indent:0;color:#23aeef;font-family:"MathDesign-CH-Regular"}#sbo-rt-content .right1{margin-top:0;margin-bottom:0;font-size:.85em;text-align:right;margin-left:0;text-indent:0;color:#23aeef;font-family:"MathDesign-CH-Regularb"}#sbo-rt-content .center{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;text-indent:0}#sbo-rt-content .centerb{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:0;font-size:.85em;text-align:center;text-indent:0;border-bottom:1px solid black;padding:0}#sbo-rt-content .centerb1{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:0;font-size:.85em;text-align:center;text-indent:0;border-bottom:1px solid black;border-left:1px solid black}#sbo-rt-content .leftd{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:.2em;padding-left:.5em;font-size:.85em;text-align:left;text-indent:0;border-bottom:1px solid black;border-left:1px solid black}#sbo-rt-content .centerl{margin-top:.1em;margin-bottom:.1em;font-size:.85em;text-align:center;margin-left:0;text-indent:0;border-left:1px solid black}#sbo-rt-content .centerlb{margin-top:0;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;text-indent:0;padding:0;border-bottom:1px solid black}#sbo-rt-content .centerlba{margin-top:0;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;text-indent:0;padding:0}#sbo-rt-content .centerlbt{margin-top:0;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;text-indent:0;padding-top:0;border-bottom:1px solid black}#sbo-rt-content .center1t{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;border-bottom:1px solid black;text-indent:0;padding-top:.1em;padding-bottom:0}#sbo-rt-content .fline{margin-top:2em;margin-bottom:.2em;border-bottom:1px solid;margin-left:0;color:#23aeef;margin-right:0;width:20%}#sbo-rt-content .bottom{border-bottom:1px solid black;padding-top:.1em;padding-right:.5em;text-align:center;font-size:.85em}#sbo-rt-content .bottom1{border-bottom:1px solid black;border-left:1px solid black;padding:.1em 0 0 .5em;text-align:center;font-size:.85em}#sbo-rt-content .space{text-align:justify;margin-top:1.5em;text-indent:0;margin-bottom:0;margin-left:0;margin-right:0}#sbo-rt-content .numlist1a{margin-top:1.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2em}#sbo-rt-content .numlist1a1{margin-top:1.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2em}#sbo-rt-content td{vertical-align:top}#sbo-rt-content .numlista{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3.05em;text-indent:-2.05em}#sbo-rt-content .numlista1{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3.05em;text-indent:-2.05em}#sbo-rt-content .left{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:0;font-size:.85em;text-align:left;text-indent:0;border-bottom:1px solid black;padding-left:.5em}#sbo-rt-content .left1{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:0;font-size:.85em;text-align:left;text-indent:0;border-bottom:1px solid black;border-left:1px solid black;padding-left:.5em;padding-right:.5em;padding-bottom:.2em}#sbo-rt-content .leftl{margin-top:.1em;margin-bottom:.1em;font-size:.85em;text-align:left;padding-left:.5em;margin-left:0;text-indent:0}#sbo-rt-content .leftl1{margin-top:.1em;margin-bottom:.1em;font-size:.85em;text-align:left;margin-left:0;text-indent:0;padding-left:.5em;border-left:1px solid black}#sbo-rt-content .leftl1a{margin-top:.1em;margin-bottom:.1em;font-size:.85em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .cbox{margin-top:1em;margin-bottom:.5em;text-indent:0;margin-left:0;margin-right:0;padding-left:.8em;padding-top:.5em;padding-bottom:.5em;padding-right:.5em;border:1px solid black}#sbo-rt-content .copys{margin-top:0;margin-bottom:0;font-size:.75em;text-align:justify;margin-left:0;text-indent:0}#sbo-rt-content p.h4{font-weight:bold;margin-top:1.5em;margin-bottom:.2em;font-size:1em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .bull{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-right:0;margin-left:1.1em;text-indent:-1.1em}#sbo-rt-content .indentta{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:1.8em;text-indent:0}#sbo-rt-content .lefta{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:1.8em;text-indent:0}#sbo-rt-content .hang3{margin-top:.7em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2em;text-indent:-1.3em}#sbo-rt-content .hang3r{margin-top:.7em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2em}#sbo-rt-content .alg{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .linet{margin-top:2em;margin-bottom:0;border-top:1.5px solid black;margin-left:0;margin-right:0}#sbo-rt-content .lineb{margin-top:0;margin-bottom:0;border-bottom:1.5px solid black;margin-left:0;margin-right:0}#sbo-rt-content .linetb{margin-top:1em;margin-bottom:2em;border-bottom:1.5px solid black;margin-left:0;margin-right:0}#sbo-rt-content .hangt{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:-2em}#sbo-rt-content .ri{text-align:right;padding-right:1em}#sbo-rt-content .tables{margin-top:1em;font-size:.85em;margin-bottom:1em;text-align:left;margin-left:1em;text-indent:0;border-collapse:collapse}#sbo-rt-content .numlist1h{margin-top:.8em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.15em;text-indent:-4.5em}#sbo-rt-content .numlist1h0{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;text-indent:-2em;margin-left:2.6em}#sbo-rt-content .numlist1h01{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.35em;text-indent:-3.85em}#sbo-rt-content .numlist1h1{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;text-indent:-2.5em;margin-left:2.5em}#sbo-rt-content .numlist1h2{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:-5em}#sbo-rt-content .numlist1hl{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:0}#sbo-rt-content .numlist1hl1{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4em;text-indent:0}#sbo-rt-content .numlist1hl2{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:0}#sbo-rt-content .numlist1hl3{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:6em;text-indent:0}#sbo-rt-content .numlist1hl4{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:7em;text-indent:0}#sbo-rt-content .numlist1hl5{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:6em;text-indent:0}#sbo-rt-content .numlistpara1aa{margin-top:.3em;margin-bottom:.3em;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:0}#sbo-rt-content .numlistpara1aa1{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.1em;text-indent:0}#sbo-rt-content .numlistpara1ab{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:0}#sbo-rt-content .hang4{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:left;margin-left:3.1em;text-indent:0}#sbo-rt-content .hang5{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;text-indent:-2em;margin-left:7em}#sbo-rt-content .hang5a{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:0}#sbo-rt-content .hang5aa{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5em;text-indent:0}#sbo-rt-content .hang4a{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.65em;text-indent:0}#sbo-rt-content .noindent3{font-size:.85em;margin-top:0;margin-bottom:0;text-align:justify;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .noindentb{font-size:.85em;margin-top:0;margin-bottom:1em;text-align:justify;margin-left:.2em;margin-right:.2em;text-indent:0}#sbo-rt-content .noindenttb{font-size:.85em;margin-top:1em;margin-bottom:1em;text-align:justify;margin-left:.2em;margin-right:.2em;text-indent:0}#sbo-rt-content .numlist2s{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2.5em}#sbo-rt-content .numlist2a{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-2em}#sbo-rt-content .numlist1bt{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3em;text-indent:-3em}#sbo-rt-content .hang3t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:3.3em;text-indent:-2.3em}#sbo-rt-content .hang23t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.8em;text-indent:-2.2em}#sbo-rt-content .hang2-4t{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.05em;text-indent:-2.55em}#sbo-rt-content .hang2-4at{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:5.75em;text-indent:-2.55em}#sbo-rt-content .td-right{margin-top:.1em;margin-bottom:0;font-size:.85em;text-align:right;margin-left:0;text-indent:0;padding-right:1em}#sbo-rt-content .td-rightb{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:0;font-size:.85em;text-align:right;text-indent:0;border-bottom:1px solid black;padding-right:1em}#sbo-rt-content .image-2{margin-top:1em;margin-bottom:0;font-size:.85em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .hanga1{margin-top:.5em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4.5em;text-indent:-4.5em}#sbo-rt-content .loweralpha1-le{margin-top:.3em;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:4em;text-indent:0}#sbo-rt-content .loweralpha1-le1{margin-top:.3em;margin-bottom:.8em;font-size:.85em;text-align:justify;margin-left:4em;text-indent:0}#sbo-rt-content .bottom-r1{border-bottom:1px solid black;border-left:1px solid black;padding:.1em 0 0 .5em}#sbo-rt-content .td-r{margin-top:0;margin-bottom:0;text-align:left;margin-left:0;text-indent:0}#sbo-rt-content .td-r1{margin-top:0;margin-bottom:0;text-align:left;margin-left:0;text-indent:0;padding-left:1.8em}#sbo-rt-content .centerlb-r{margin-top:0;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0;padding:0;border-bottom:1px solid black}#sbo-rt-content .centerlb-rs{margin-top:0;margin-bottom:0;font-size:.85em;text-align:left;margin-left:0;text-indent:0;padding:0}#sbo-rt-content .left1s{margin-top:.1em;margin-bottom:.1em;margin-right:0;margin-left:0;font-size:.85em;text-align:left;text-indent:0;border-left:1px solid black;padding-left:.5em}#sbo-rt-content .table3{margin-top:1em;margin-bottom:1em;text-align:left;margin-left:1em;text-indent:0;border-collapse:collapse}#sbo-rt-content .indextop{margin-top:1em;margin-bottom:0;font-size:.75em;text-align:left;margin-left:3.9em;text-indent:-3.9em}#sbo-rt-content .numlist1h3{margin-top:0;margin-bottom:0;font-size:.85em;text-align:justify;margin-left:2.5em;text-indent:0}#sbo-rt-content span.code{font-family:"cour";font:monospace}#sbo-rt-content span.math1{font-family:"MathDesign-CH-Regular"}#sbo-rt-content span.math2{font-family:"MathDesign-CH-Regular1"}#sbo-rt-content span.mat1{font-family:"DejaVuSans"}#sbo-rt-content span.mt1{font-family:"MathDesign-CH-Regularb"}#sbo-rt-content .block{vertical-align:top}#sbo-rt-content .mathe{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe0{font-size:.85em;margin-top:.7em;margin-bottom:0;text-align:left;margin-left:1.5em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe0a{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:1.5em;margin-right:1em;text-indent:0}#sbo-rt-content .mathet{font-size:.85em;margin-top:.7em;margin-bottom:0;text-align:left;margin-left:2.5em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe1t{font-size:.85em;margin-top:.5em;margin-bottom:0;text-align:left;margin-left:3.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe1{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:3.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:4.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2t{font-size:.85em;margin-top:.5em;margin-bottom:0;text-align:left;margin-left:4.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2a{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:5.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2at{font-size:.85em;margin-top:.5em;margin-bottom:0;text-align:left;margin-left:5.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2b{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:6.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2bb{font-size:.85em;margin-top:0;margin-bottom:.5em;text-align:left;margin-left:6.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2bt1{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:6.6em;margin-right:1em;text-indent:0}#sbo-rt-content .mathe2c{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:7.6em;margin-right:0;text-indent:0}#sbo-rt-content .mathe2d{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:7.5em;margin-right:0;text-indent:0}#sbo-rt-content .mathe3{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:7em;margin-right:0;text-indent:0}#sbo-rt-content .mathe2e{font-size:.85em;margin-top:0;margin-bottom:0;text-align:left;margin-left:8em;margin-right:0;text-indent:0}#sbo-rt-content .tablef{margin-top:1em;margin-bottom:1em;text-align:left;margin-left:1em;text-indent:0;font-size:.85em}#sbo-rt-content .math{margin-top:1em;margin-bottom:1em;font-size:.85em;text-align:center;margin-left:0;text-indent:0;line-height:1.2em}#sbo-rt-content .a1{font-family:"opens"}</style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9781284056242/chapter/xhtml/04_Contents.xhtml",
          "book_id": "9781284056242",
          "chapter_uri": "xhtml/04_Contents.xhtml",
          "position": 0,
          "user_uuid": "7f975f1c-dea3-4e80-99fb-9a28ca51d787",
          "next_chapter_uri": "/library/view/essentials-of-discrete/9781284056242/xhtml/05_Preface.xhtml"
        
      },
      title: "Essentials of Discrete Mathematics, 3rd Edition",
      author_list: "David J. Hunter",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false,
      show_ios_app_teaser: false
    };
    // ]]></script><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

    
      window.PRIVACY_CONTROL_SWITCH = true;
    

    
      window.PUBLISHER_PAGES = true;
    

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "/api/v2/search/select/",
          "ENABLE_ONLINE_TRAINING": true
        }
      };
  </script><link rel="canonical" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml"><meta name="description" content="Contents Preface How to Use This Book Chapter 1 Logical Thinking 1.1  Formal Logic 1.1.1  Inquiry Problems 1.1.2  Connectives and Propositions 1.1.3  Truth ... "><meta property="og:title" content="Contents"><meta itemprop="isPartOf" content="/library/view/essentials-of-discrete/9781284056242/"><meta itemprop="name" content="Contents"><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9781284056242/"><meta property="og:description" itemprop="description" content="Contents Preface How to Use This Book Chapter 1 Logical Thinking 1.1  Formal Logic 1.1.1  Inquiry Problems 1.1.2  Connectives and Propositions 1.1.3  Truth ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="Jones &amp; Bartlett Learning"><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="9781284056259"><meta property="og:book:author" itemprop="author" content="David J. Hunter"><meta property="og:book:tag" itemprop="about" content="Math &amp; Science"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: &lt;%= font_size %&gt; !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: &lt;%= font_family %&gt; !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: &lt;%= column_width %&gt;% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; url=/library/no-js/" /></noscript><script type="text/javascript">
    (function(i,s,o,g,r,a,m) {
      i['GoogleAnalyticsObject']=r;
      i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();
      a=s.createElement(o),m=s.getElementsByTagName(o)[0];
      a.async=1;
      a.src=g;
      m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    var matches = document.cookie.match(/BrowserCookie\s*=\s*([a-f0-9\-]{36})/),
      user_uuid = null;

    if (matches && matches.length === 2) {
      user_uuid = matches[1];
    }

  
    ga('create', 'UA-39299553-7', {'userId': '7f975f1c-dea3-4e80-99fb-9a28ca51d787' });
  

  
    
      ga('set', 'dimension1', 'Paid');
    
  

  ga('set', 'dimension6', user_uuid);

  
    ga('set', 'dimension2', '7f975f1c-dea3-4e80-99fb-9a28ca51d787');
    
  

  

  

  //enable enhanced link tracking
  ga('require', 'linkid', 'linkid.js');

  // reading interface will track pageviews itself
  if (document.location.pathname.indexOf("/library/view") !== 0) {
    ga('send', 'pageview');
  }
  </script><script>
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
  </script><script defer="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/vendor.525b10593cd3.js"></script><script defer="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/reader.ab76df595926.js"></script><script async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/MathJax.js"></script><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 2147483020;
}
.annotator-filter {
  z-index: 2147483010;
}</style><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f(1).txt"></script><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f(2).txt"></script><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f(3).txt"></script><script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/f(4).txt"></script><style type="text/css" id="kampyleStyle">.noOutline{outline: none !important;}.wcagOutline:focus{outline: 1px dashed #595959 !important;outline-offset: 2px !important;transition: none !important;}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts library">

    
  <noscript> 
    <iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        





<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://learning.oreilly.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://learning.oreilly.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z"></path></g></svg><span>Recommended</span></a></li><li><a href="https://learning.oreilly.com/playlists/" class="t-queue-nav l0 nav-icn None"><!--?xml version="1.0" encoding="UTF-8"?--><svg width="21px" height="17px" viewBox="0 0 21 17" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --><title>icon_Playlist_sml</title><desc>Created with Sketch.</desc><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="icon_Playlist_sml" fill-rule="nonzero" fill="#000000"><g id="playlist-icon"><g id="Group-6"><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle></g><g id="Group-5" transform="translate(0.000000, 7.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g><g id="Group-5-Copy" transform="translate(0.000000, 14.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g></g></g></g></svg><span>
               Playlists
            </span></a></li><li class="search"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://learning.oreilly.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z"></path></g></svg><span>History</span></a></li><li><a href="https://learning.oreilly.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" width="20" height="20" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z"></path></g></svg><span>Topics</span></a></li><li><a href="https://learning.oreilly.com/learning-paths/" class="l1 nav-icn t-learningpaths-nav js-toggle-menu-item"><!--?xml version="1.0" encoding="UTF-8"?--><svg width="32px" height="32px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><!-- Generator: Sketch 52.5 (67469) - http://www.bohemiancoding.com/sketch --><title>Mask</title><desc>Created with Sketch.</desc><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M0,16.0214227 C0,15.0387209 0.796453294,14.2411658 1.77779753,14.2411658 C2.75914177,14.2411658 3.55559506,15.0387209 3.55559506,16.0214227 C3.55559506,17.0041246 2.75914177,17.8016797 1.77779753,17.8016797 C0.796453294,17.8016797 0,17.0041246 0,16.0214227 Z M9.77788642,5.22914885 C8.9280992,5.72049977 7.84008711,5.42853763 7.34941499,4.57757479 C6.85874287,3.72661195 7.15030167,2.63709467 8.00008889,2.14574375 C8.84987611,1.65439282 9.9378882,1.94635496 10.4285603,2.7973178 C10.9192324,3.64828064 10.6276736,4.73779792 9.77788642,5.22914885 Z M4.57213969,7.35869225 C5.42192691,7.85004318 5.71348571,8.93956046 5.22281359,9.79052329 C4.73214147,10.6414861 3.64412938,10.9334483 2.79434216,10.4420974 C1.94455494,9.95074642 1.65299614,8.86122915 2.14366826,8.01026631 C2.63434038,7.15930347 3.72235247,6.86734132 4.57213969,7.35869225 Z M2.79434216,21.6007481 C3.64412938,21.1093972 4.73214147,21.4013594 5.22281359,22.2523222 C5.71348571,23.103285 5.42192691,24.1928023 4.57213969,24.6841532 C3.72235247,25.1755042 2.63434038,24.883542 2.14366826,24.0325792 C1.65299614,23.1816163 1.94455494,22.0920991 2.79434216,21.6007481 Z M7.34941499,27.4652707 C7.84008711,26.6143079 8.9280992,26.3223457 9.77788642,26.8136966 C10.6276736,27.3050476 10.9192324,28.3945649 10.4285603,29.2455277 C9.9378882,30.0964905 8.84987611,30.3884527 8.00008889,29.8971017 C7.15030167,29.4057508 6.85874287,28.3162335 7.34941499,27.4652707 Z M18.7118524,11.3165596 C21.3074367,12.8173162 22.1963355,16.1392758 20.6976522,18.738451 C19.1989689,21.3358459 15.8815987,22.2259744 13.2860143,20.726998 C10.6922077,19.2262414 9.80330893,15.9042818 11.3002144,13.3051066 C12.7988978,10.7059314 16.116268,9.81580294 18.7118524,11.3165596 Z M26.7821642,27.8093944 L30.1315348,31.1633985 C30.3982044,31.4304371 30.2097579,31.8844026 29.8346426,31.8844026 L21.5945511,31.8844026 C21.1287681,31.8844026 20.751875,31.5069881 20.751875,31.0405608 L20.751875,22.7890697 C20.751875,22.4134355 21.2052134,22.2247282 21.4701052,22.4899865 L24.2843587,25.3081333 C26.8337204,23.0240636 28.4444049,19.7092251 28.4444049,16.0223129 C28.4444049,9.15052091 22.8621207,3.56051397 15.9998222,3.56051397 L15.9998222,0 C24.8230314,0 32,7.18689745 32,16.0223129 C32,20.6919269 29.9750886,24.8790914 26.7821642,27.8093944 Z" id="Mask" fill="#8B889A"></path></g></svg><span>Learning Paths</span></a></li><li class="nav-offers flyout-parent"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>offers icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M35.9 20.6L27 15.5C26.1 15 24.7 15 23.7 15.5L14.9 20.6C13.9 21.1 13.2 22.4 13.2 23.4L13.2 41.4C13.2 42.4 13.9 43.7 14.9 44.2L23.3 49C24.2 49.5 25.6 49.5 26.6 49L35.9 43.6C36.8 43.1 37.6 41.8 37.6 40.8L37.6 23.4C37.6 22.4 36.8 21.1 35.9 20.6L35.9 20.6ZM40 8.2C39.1 7.6 37.6 7.6 36.7 8.2L30.2 11.9C29.3 12.4 29.3 13.2 30.2 13.8L39.1 18.8C40 19.4 40.7 20.6 40.7 21.7L40.7 39C40.7 40.1 41.4 40.5 42.4 40L48.2 36.6C49.1 36.1 49.8 34.9 49.8 33.8L49.8 15.6C49.8 14.6 49.1 13.3 48.2 12.8L40 8.2 40 8.2ZM27 10.1L33.6 6.4C34.5 5.9 34.5 5 33.6 4.5L26.6 0.5C25.6 0 24.2 0 23.3 0.5L16.7 4.2C15.8 4.7 15.8 5.6 16.7 6.1L23.7 10.1C24.7 10.6 26.1 10.6 27 10.1ZM10.1 21.7C10.1 20.6 10.8 19.4 11.7 18.8L20.6 13.8C21.5 13.2 21.5 12.4 20.6 11.9L13.6 7.9C12.7 7.4 11.2 7.4 10.3 7.9L1.6 12.8C0.7 13.3 0 14.6 0 15.6L0 33.8C0 34.9 0.7 36.1 1.6 36.6L8.4 40.5C9.3 41 10.1 40.6 10.1 39.6L10.1 21.7 10.1 21.7Z"></path></g></svg><span>Offers &amp; Deals</span></a><ul class="flyout"><li><a href="https://get.oreilly.com/email-signup.html" target="_blank" class="l2 nav-icn"><span>Newsletters</span></a></li></ul></li><li class="nav-highlights"><a href="https://learning.oreilly.com/u/7f975f1c-dea3-4e80-99fb-9a28ca51d787/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" width="20" height="20" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z"></path></g></svg><span>Highlights</span></a></li><li><a href="https://learning.oreilly.com/u/preferences/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l1 no-icon">Support</a></li><li><a href="https://learning.oreilly.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://learning.oreilly.com/u/preferences/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l2">Support</a></li><li><a href="https://learning.oreilly.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application" style="height: auto;">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Essentials of Discrete Mathematics, 3rd Edition
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9781284056242/chapter/xhtml/04_Contents.xhtml"><div class="js-collections-dropdown collections-dropdown menu-bit-cards"><div data-reactroot="" class="menu-dropdown-wrapper js-menu-dropdown-wrapper align-right"><img class="hidden" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/ajax-transp.gif" alt="loading spinner"><div class="menu-control"><div class="control "><div class="js-playlists-menu"><button class="js-playlist-icon"><svg class="icon-add-to-playlist-sml" viewBox="0 0 16 14" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill-rule="nonzero" fill="#000000"><g transform="translate(-1.000000, 0.000000)"><rect x="5" y="0" width="12" height="2"></rect><title>Playlists</title><path d="M4.5,14 C6.43299662,14 8,12.4329966 8,10.5 C8,8.56700338 6.43299662,7 4.5,7 C2.56700338,7 1,8.56700338 1,10.5 C1,12.4329966 2.56700338,14 4.5,14 Z M2.5,10 L4,10 L4,8.5 L5,8.5 L5,10 L6.5,10 L6.5,11 L5,11 L5,12.5 L4,12.5 L4,11 L2.5,11 L2.5,10 Z"></path><circle cx="2" cy="5" r="1"></circle><circle cx="1.94117647" cy="1" r="1"></circle><rect x="5" y="4" width="12" height="2"></rect><rect x="9" y="8" width="8" height="2"></rect><rect x="9" y="12" width="8" height="2"></rect></g></g></g></svg><div class="js-playlist-addto-label">Add&nbsp;To</div></button></div></div></div></div></div></div></li><li class="js-font-control-panel font-control-activator"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml&amp;text=Essentials%20of%20Discrete%20Mathematics%2C%203rd%20Edition&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%20Contents&amp;body=https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/04_Contents.xhtml%0D%0Afrom%20Essentials%20of%20Discrete%20Mathematics%2C%203rd%20Edition%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 4 Quantitative Thinking</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 6 Thinking Through Applications</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="annotator-wrapper"><p class="chapnum"><span epub:type="pagebreak" id="page_295"></span>Chapter 5</p>
<p class="chaptitle">Analytical Thinking</p>
<p class="noindent">The ways of thinking we have studied so far—logical, relational, recursive, and quantitative—have highlighted different aspects of discrete problems in mathematics. In this chapter we draw on many of the topics from earlier in the book to help us analyze algorithms. In addition to understanding what an algorithm does, we will study mathematical ways to determine the accuracy and efficiency of algorithms. This type of analysis is fundamentally important to computer scientists. And, as computing becomes increasingly important in other fields, scholars from many disciplines will need to be able to think this way.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig295-1.jpg" alt="Image" width="1128" height="847" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig295-1.jpg"></p>
<p class="figcaptionj"><b><span class="blue">Figure 5.1</span></b> A raytraced image of three objects with mirrored surfaces. Raytracers use recursive algorithms to calculate reflections, and reflections of reflections, etc. How many reflections can you find?</p>
</div>
<p class="h1"><a id="ch5sub1"></a><span epub:type="pagebreak" id="page_296"></span><b>5.1&nbsp;&nbsp;&nbsp;Algorithms</b></p>
<p class="noindent">We have already been dealing with simple algorithms. The recursive functions of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml">Chapter 3</a> and the pseudocode segments of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml">Chapter 4</a> defined short algorithms. In this section we will review and expand on these topics.</p>
<div class="box">
<p class="noindent1"><b>Inquiry 5.1</b> Anthony and Berenice are playing a guessing game. Anthony thinks of a natural number between 1 and 10, inclusive. Berenice tries to guess the number. After each guess, Anthony tells Berenice if her guess was correct, too high, or too low. Devise an efficient strategy for Berenice to determine Anthony’s number with the fewest possible guesses.</p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.2</b> Eighteen spectators are sitting in a row at a football game. Nine white hats and nine black hats are distributed randomly to these 18 spectators. For the halftime show, the hats are supposed to alternate colors—black, white, black, white, etc.—across the entire row. Describe an efficient method for rearranging these hats to achieve this desired effect.</p>
</div>
<p class="h2"><a id="ch5sub1sub1"></a><b>5.1.1&nbsp;&nbsp;&nbsp;More Pseudocode</b></p>
<p class="noindent">An algorithm is basically a list of instructions (statements) that need to be executed in sequence. Sometimes we need to be able to skip statements, or we might wish to repeat a statement several times. The following definitions will give us ways of doing this.</p>
<p class="noindentt"><a id="ch5def1"></a><b>Definition 5.1</b> Let <i>p</i> be a logical statement that is either true or false. Then the <span class="code">if…then…else</span> statement</p>
<p class="mathet"><code>if</code> <i>p</i> <code>then</code></p>
<p class="mathe1"><code>statement</code><sub>1</sub></p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><code>statement</code><sub>2</sub></p>
<p class="noindentt">will execute either <code>statement</code><sub>1</sub> or <code>statement</code><sub>2</sub>, depending on whether <i>p</i> is true or false, respectively.</p>
<p class="indent"><span epub:type="pagebreak" id="page_297"></span>We used <code>if…then</code> statements in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml">Chapter 4</a>, but <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5def1">Definition 5.1</a> adds an <code>else</code> clause to this command. An <code>if…then…else</code> statement is the pseudocode equivalent of a binary branch in a decision tree.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis297-1.png" alt="Image" width="369" height="133" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis297-1.png"></p>
<p class="indent">In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml">Chapter 4</a> we used <code>for</code>-loops to repeat a statement a specified number of times. The following definition gives a more versatile looping structure.</p>
<p class="noindentt"><a id="ch5def2"></a><b>Definition 5.2</b> Let <i>P</i>(<i>x</i>) be a predicate statement. Then the <code>while-loop</code></p>
<p class="mathet"><code>while</code> <i>P</i>(<i>x</i>) <code>do</code></p>
<p class="mathe2"><code>statement</code>(<i>x</i>)</p>
<p class="noindentt">will continue to execute <code>statement</code>(<i>x</i>) as long as <i>P</i>(<i>x</i>) remains true.</p>
<p class="noindentt">A <code>while</code>-loop will run forever unless <code>statement</code>(<i>x</i>) changes the value of <i>x</i> so that <i>P</i>(<i>x</i>) can be false. If <i>P</i>(<i>x</i>) is false to begin with, then <code>statement</code>(<i>x</i>) is never executed. The number of times a <code>while</code>-loop repeats depends on the pseudocode that changes the value of <i>x</i>. This behavior is different from a <code>for</code>-loop, which always executes a predetermined number of times.</p>
<p class="indent">The following algorithm illustrates <code>if…then…else</code> statements and <code>while</code>-loops. The purpose of this algorithm is to determine if a given <i>target</i> element <i>t</i> is present in an array. (For convenience, we omit the quotes from the <code>print</code> statements.)</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo1"></a><b>Algorithm 5.1</b> Sequential Search. Let <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> be an array of elements from some set <i>U</i>, and let <i>t</i> ∈ <i>U</i>. The following algorithm performs a <i>sequential search</i> of this array.</p>
<p class="lineb"></p>
<p class="mathet"><i>i</i> ← 1</p>
<p class="mathe"><i>x</i><sub><i>n</i>+1</sub> ← <i>t</i></p>
<p class="mathe"><code>while</code> <i>t</i> ≠ <i>x<sub>i</sub></i> <code>do</code></p>
<p class="mathe2"><i>i</i> ← <i>i</i> + 1</p>
<p class="mathe"><code>if</code> <i>i</i> = <i>n</i> + 1 <code>then</code></p>
<p class="mathe1"><code>print</code> Element <i>t</i> was not found.</p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><code>print</code> Element <i>t</i> was found in location <i>i</i>.</p>
<p class="linetb"></p>
<p class="indentt">In the sequential search algorithm, the <code>while</code>-loop will continue to increment <i>i</i> while the statement (<i>t</i> ≠ <i>x<sub>i</sub></i>) is true. In other words, it will stop executing when <i>t</i> = <i>x<sub>i</sub></i>. Note that this must happen, since we put a copy of <i>t</i> at the end of the list as <span epub:type="pagebreak" id="page_298"></span>a ‘‘sentinel” value. If <i>i</i> = <i>n</i> + 1 after the loop finishes executing, then the loop will have run through all the values in the original array without finding one equal to <i>t</i>. In this case, <i>t</i> was not found in the array. Otherwise <i>t</i> was found, and <i>x<sub>i</sub></i> = <i>t</i>.</p>
<p class="indent">For example, suppose the array contains five integers (<i>n</i> = 5) whose values are as follows.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis298-1.png" alt="Image" width="316" height="81" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis298-1.png"></p>
<p class="noindent">A <i>trace</i> of an algorithm is a step-by-step description of what happens when the algorithm executes. The following table describes a trace of the <code>while</code>-loop in the sequential search. Suppose that <i>t</i> = 12 is the target value we are searching for.</p>
<table style="width:100%; padding:0em; border-spacing:0em;" class="table">
<tbody><tr>
<td class="bottom" style="width:50%;"><span class="blue"><i>i</i></span></td>
<td class="bottom1" style="width:50%;"><span class="blue">test</span></td>
</tr>
<tr>
<td class="center">1</td>
<td class="centerl"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in298-1.png" alt="Image" width="68" height="27" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in298-1.png"></td>
</tr>
<tr>
<td class="center">2</td>
<td class="centerl"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in298-2.png" alt="Image" width="68" height="27" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in298-2.png"></td>
</tr>
<tr>
<td class="center">3</td>
<td class="centerl"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in298-3.png" alt="Image" width="68" height="28" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in298-3.png"></td>
</tr>
<tr>
<td class="center">4</td>
<td class="centerl"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in298-4.png" alt="Image" width="80" height="26" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in298-4.png"></td>
</tr>
</tbody></table>
<p class="noindentt">At this point, the <code>while</code>-loop terminates and the <code>if…then…else</code> statement executes. Since 4 ≠ 5 + 1, the <code>else</code> clause prints the following message.</p>
<p class="image">Element 12 was found in location 4.</p>
<p class="h2"><a id="ch5sub1sub2"></a><b>5.1.2&nbsp;&nbsp;&nbsp;Preconditions and Postconditions</b></p>
<p class="noindent">Usually, an algorithm has a purpose. We can describe what an algorithm is supposed to do using <i>preconditions</i> and <i>postconditions</i>.</p>
<p class="noindentt"><a id="ch5def3"></a><b>Definition 5.3</b> Let <i>A</i> be an algorithm. A <i>precondition</i> of <i>A</i> is a statement about algorithm variables before <i>A</i> executes. A <i>postcondition</i> of <i>A</i> is a statement about the algorithm variables after execution.</p>
<p class="noindentt">Writing good preconditions and postconditions is like writing clear mathematical statements. A precondition should specify exactly what needs to be true before an algorithm runs in order for it to do its job properly. Similarly, a postcondition should say precisely what will be true after the algorithm runs, assuming the preconditions are satisfied.</p>
<p class="noindentt"><a id="ch5ex1"></a><span epub:type="pagebreak" id="page_299"></span><b><span class="blue">Example 5.1</span></b> Consider the bubble sort algorithm of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex55">Example 4.55</a>. We’ll reprint it here for convenience.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo2"></a><b>Algorithm 5.2</b> Bubble Sort.</p>
<p class="lineb"></p>
<p class="mathet"><code>for</code> <i>i</i> ∈ {1,2, …, <i>n</i> − 1} <code>do</code></p>
<p class="mathe1"><span class="mat1">⌜</span> <code>for</code> <i>j</i> ∈ {1,2, …, <i>n</i> – <i>i</i>} <code>do</code></p>
<p class="mathe1"><span class="mat1">⌞</span>&nbsp;&nbsp;&nbsp;<code>if</code> <i>x<sub>j</sub></i> &gt; <i>x</i><sub><i>j</i>+1</sub> <code>then swap</code> <i>x<sub>j</sub></i> <code>and</code> <i>x</i><sub><i>j</i>+1</sub></p>
<p class="linetb"></p>
<p class="indent">This (and any other sorting algorithm) is supposed to put the elements of an array in order. Mathematically speaking, we have the following preconditions.</p>
<p class="blockquote">Preconditions: The elements of the array <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, …, <i>x<sub>n</sub></i> can be compared by ≤. In addition, <i>n</i> ≥ 2.</p>
<p class="noindent">In order for the algorithm to work, the comparison <i>x<sub>j</sub></i> &gt; <i>x</i><sub><i>j</i>+1</sub> needs to make sense for any <i>j</i>. This explains the need for the first precondition. The second precondition ensures that the index sets {1, 2, …, <i>n</i> − 1} and {1, 2, …, <i>n</i> − <i>i</i>} are well defined.</p>
<p class="indent">The only postcondition is that the array is in order after the algorithm executes.</p>
<p class="blockquote">Postcondition: <i>x</i><sub>1</sub> ≤ <i>x</i><sub>2</sub> ≤ <i>x</i><sub>3</sub> ≤ · · · ≤ <i>x<sub>n</sub></i>.</p>
<p class="indent">Think of preconditions and postconditions from the point of view of the user, or consumer, of an algorithm. The preconditions are the operating instructions in the owner’s manual; they specify the proper way to use the algorithm. The postconditions are a performance guarantee; as long as the consumer upholds the preconditions, the algorithm promises to deliver the postconditions.</p>
<p class="indent">We can describe the roles of preconditions and postconditions more mathematically, in terms of logic. Consider an algorithm with preconditions <i>p</i><sub>1</sub>, <i>p</i><sub>2</sub>, …, <i>p<sub>k</sub></i> and postconditions <i>q</i><sub>1</sub>, <i>q</i><sub>2</sub>, …, <i>q<sub>l</sub></i>. We say that the algorithm is <i>correct</i> if</p>
<p class="image"><i>p</i><sub>1</sub> ∧ <i>p</i><sub>2</sub> ∧ … ∧ <i>p</i><sub>k</sub> ⇒ <i>q</i><sub>1</sub> ∧ <i>q</i><sub>2</sub> ∧ … ∧ <i>q</i><sub>l</sub></p>
<p class="noindent">where the preconditions <i>p<sub>i</sub></i> are evaluated before algorithm execution, and the postconditions <i>q<sub>i</sub></i> are evaluated after execution. This mathematical statement can be proved as a theorem; such a proof is called a <i>proof of correctness</i>. We will do these kinds of proofs in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub5">Sections 5.5</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub6">5.6</a>.</p>
<p class="noindentt"><a id="ch5ex2"></a><b><span class="blue">Example 5.2</span></b> Any <code>while</code>-loop of the form</p>
<p class="mathet"><code>while</code> <i>P</i>(<i>x</i>) <code>do</code></p>
<p class="mathe2"><code>statement</code>(<i>x</i>)</p>
<p class="noindentt">has</p>
<p class="mathet">Postcondition: ¬<i>P</i>(<i>x</i>)</p>
<p class="noindent">because the loop will continue to execute as long as <i>P</i>(<i>x</i>) is true.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_300"></span><a id="ch5ex3"></a><b><span class="blue">Example 5.3</span></b> Consider the sequential search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>). Before the algorithm executes, we have a set {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} and a target value <i>t</i>. The algorithm is supposed to tell us if the target <i>t</i> is a member of the set. If it is, the value of <i>i</i> should be set so that <i>x<sub>i</sub></i> = <i>t</i>. In mathematical language, we have the following:</p>
<p class="mathet">Preconditions: {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ U</p>
<p class="mathe3"><i>t</i> ∈ <i>U</i></p>
<p class="mathe">Postconditions: <i>t</i> = <i>x<sub>i</sub></i></p>
<p class="mathe3"><i>i</i> ∈ {1,2, …, <i>n</i> + 1}</p>
<p class="mathe3">(<i>i</i> = <i>n</i> + 1) ⇒ (<i>t</i> ∉ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>}).</p>
<p class="noindentt">We will prove that these conditions hold (i.e., that the algorithm is correct) in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub6">Section 5.6</a>.</p>
<p class="h2"><a id="ch5sub1sub3"></a><b>5.1.3&nbsp;&nbsp;&nbsp;Iterative Algorithms</b></p>
<p class="noindent">An algorithm that repeats a segment of code several times in a loop is called an <i>iterative</i> algorithm. The bubble sort and sequential search are iterative. Here is another searching algorithm.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo3"></a><b>Algorithm 5.3</b> Binary Search (iterative).</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: The set <i>U</i> is totally ordered by &lt;, and <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <i>U</i>, with <i>n</i> ≥ 1,</p>
<p class="image"><i>x</i><sub>1</sub> &lt; <i>x</i><sub>2</sub> &lt; ··· &lt; <i>x<sub>n</sub></i>,</p>
<p class="indent">&nbsp;&nbsp;and <i>t</i> ∈ <i>U</i>.</p>
<p class="hang3">Postconditions: (<i>t</i> ∉ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>}) ∨ (<i>x<sub>l</sub></i> = <i>t</i>)</p>
<p class="mathet"><i>l</i> ← 1, <i>r</i> ← <i>n</i></p>
<p class="mathe"><code>while</code> <i>l</i> &lt; <i>r</i> <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>i</i> ← ⌊(<i>l</i> + <i>r</i>)/2⌋</p>
<p class="mathe2a"><code>if</code> <i>t</i> &gt; <i>x<sub>i</sub></i> <code>then</code></p>
<p class="mathe2b"><i>l</i> ← <i>i</i> + 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2"><span class="mat1">⌞</span> <i>r</i> ← <i>i</i></p>
<p class="mathe"><code>if</code> <i>t</i> = <i>x<sub>l</sub></i> <code>then</code></p>
<p class="mathe1"><code>print</code> Element <i>t</i> was found in location <i>l</i>.</p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><code>print</code> Element <i>t</i> was not found.</p>
<p class="linetb"></p>
<p class="indent"><span epub:type="pagebreak" id="page_301"></span>Let’s trace the binary search algorithm when the program variables are initially as follows.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/tab301-1.png" alt="Image" width="645" height="119" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/tab301-1.png"></p>
<p class="noindent">There are two tests, or comparisons, in this algorithm: <i>l</i> &lt; <i>r</i> and <i>t</i> &gt; <i>x<sub>i</sub></i>. As we step through the pseudocode, each time we encounter a test we go on to a new line in the table.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/tab301-2.png" alt="Image" width="699" height="400" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/tab301-2.png"></p>
<p class="noindent">At this point, the <code>while</code>-loop finishes, and the program reports that 12 was found in location 4.</p>
<p class="indent">The binary search works by eliminating approximately half of the remaining items in the array from consideration each time through the <code>while</code>-loop. This is possible because the array items are in order; if the target <i>t</i> is greater than the middle array element, the algorithm eliminates the bottom half of the array, and <i>vice versa</i>. In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub6">Section 5.6</a>, we will prove that the binary search always finds the target, if it is present in the array.</p>
<p class="h2"><a id="ch5sub1sub4"></a><b>5.1.4&nbsp;&nbsp;&nbsp;Functions and Recursive Algorithms</b></p>
<p class="noindent">To write a function in pseudocode, we use a <code>return</code> statement.</p>
<p class="noindentt"><span class="blue"><b>Example 5.4</b></span> The following pseudocode defines the function <i>f</i> (<i>x</i>) = <i>x</i><sup>2</sup>.</p>
<p class="mathet"><code>function SquareIt</code>(<i>x</i> ∈ <b>R</b>)</p>
<p class="mathe1"><i>t</i> ← <i>x</i><sup>2</sup></p>
<p class="mathe1"><code>return</code> <i>t</i></p>
<p class="noindentt">This function inputs a real number <i>x</i> and outputs, or <i>returns, x</i><sup>2</sup>. The variable <i>x</i> is called a <i>parameter</i>; it stores a value of the domain that gets “plugged into” the function. The notation for functions in pseudocode is the same as the notation in mathematics: to evaluate <i>f</i> (7), we use the <i>function call</i> <code>SquareIt(7)</code>.</p>
<p class="indent">When a call to function appears in a pseudocode statement, the effect is the same as if the returned value takes the place of the function call. So if</p>
<p class="image"><code>SquareIt(7)</code></p>
<p class="noindent"><span epub:type="pagebreak" id="page_302"></span>appeared anywhere in a pseudocode statement, we could effectively replace it with 49. The statement</p>
<p class="blockquote"><code>print SquareIt(4) + SquareIt(5)</code></p>
<p class="noindent">would print the number 41.</p>
<p class="indentt">In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml">Chapter 3</a>, we studied recursive functions. Recall that the definition of a recursive function includes a nonrecursive base case and a recursive part that defines the function in terms of itself. In this chapter we can think of recursive functions algorithmically; a recursive algorithm contains a call to itself.</p>
<p class="noindentt"><a id="ch5ex5"></a><span class="blue"><b>Example 5.5</b></span> Recall that a recurrence relation is a simple type of recursive function. Let <i>S</i>(<i>n</i>) be defined by the following recurrence relation:</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq302-2.png" alt="Image" width="482" height="78" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq302-2.png"></p>
<p class="noindent">The pseudocode version of this recursive function is as follows.</p>
<p class="mathet"><code>function S</code>(<i>n</i> ∈ <b>N</b>)</p>
<p class="mathe1"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2"><code>return</code> 1</p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><code>return S</code>(<i>n</i> − 1) + 2<i>n</i> − 1</p>
<p class="noindentt">Notice how the base and recursive cases translate directly into pseudocode: The <code>if…then…else</code> statement tests the appropriate condition and chooses which case to apply.</p>
<p class="indent">Suppose the function call <code>S</code>(5) appears in some pseudocode segment. Since 5 ≠ 1, the <code>else</code> clause is executed, so this function call is effectively the same as <code>S</code>(4)+9, the return value. But now <i>S</i>(4) needs to be evaluated, and its return value is <code>S</code>(3)+7. Similarly, <code>S</code>(3) returns <code>S</code>(2)+5 and <code>S</code>(2) returns <code>S</code>(1)+3. But now the call to <code>S</code>(1) invokes the nonrecursive <code>if</code> clause, and simply returns 1. Therefore the return value of <code>S</code>(2) is effectively the same as 1 + 3 = 4, since the <code>S</code>(1) can be replaced by 1. And now we can use 4 in place of <code>S</code>(2) to see that the return value of <code>S</code>(3) is equivalent to 4 + 5 = 9. Continuing in this fashion, the return value of <code>S</code>(4) is 9 + 7 = 16 and, finally, the return value of <code>S</code>(5) is 16 + 9 = 25.</p>
<p class="indent">We can outline this calculation a little more concisely as follows:</p>
<table style="width:100%; padding:0em; border-spacing:0em;" class="tablef">
<tbody><tr>
<td style="width:15%;" class="td-r"><code>S</code>(5)</td>
<td style="width:85%;" class="td-r">= <code>S</code>(4) + 9</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>S</code>(3) + 7 + 9</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>S</code>(2) + 5 + 7 + 9</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>S</code>(1) + 3 + 5 + 7 + 9</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= 1 + 3 + 5 + 7 + 9</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= 25.</td>
</tr>
</tbody></table>
<p class="noindent"><span epub:type="pagebreak" id="page_303"></span>This way of tracing through the execution of a recursive function is called a <i>top-down evaluation</i>. We start at the “top” with the original value of the parameter <i>n</i>, and we continue “down” until there are no more recursive calls. At this point we say that the recursive algorithm <i>bottoms out</i>, and we are able to compute the final return value.</p>
<p class="indentt">You may have noticed that you have seen the recurrence relation in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex5">Example 5.5</a> before; in Exercise 1 in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3sub4">Section 3.4</a> you were asked to prove that the sum of the first <i>n</i> odd natural numbers is <i>n</i><sup>2</sup>. The recurrence relation for <i>S</i>(<i>n</i>) computes this sum, so the pseudocode version can be thought of as a recursive algorithm for squaring a natural number. Many of the recursive definitions from <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml">Chapter 3</a> translate naturally into recursive algorithms in pseudocode.</p>
<p class="noindentt"><a id="ch5ex6"></a><span class="blue"><b>Example 5.6</b></span> Recall the string reversal function of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3ex18">Example 3.18</a> on page 178. The pseudocode version is as follows.</p>
<p class="mathet"><code>function Reverse</code>(<i>s</i> ∈ {<code>strings</code>})</p>
<p class="mathe1"><code>if</code> <i>s</i> = λ <code>then</code></p>
<p class="mathe2"><code>return</code> λ</p>
<p class="mathe"><code>else</code>   <code>// assert:</code> <i>s</i> = <i>ra</i></p>
<p class="mathe1"><code>return</code> <i>a</i> <code>Reverse</code>(<i>r</i>)</p>
<p class="noindentt">The <code>assert</code> comment tells us something that should be true at that point in the program. In this case, we know that if a string is not empty, it must be the concatenation of a (possibly empty) string <i>r</i> and a symbol <i>a</i>.</p>
<p class="indent">The structure of the <code>Reverse</code> function is typical of recursive algorithms. The <code>if…then…else</code> statement divides the body of the function into two parts: a base case and a recursive case.</p>
<p class="indent">Let’s perform a top-down evaluation of this function. Compare the following calculation with <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3ex18">Example 3.18</a> on page 178.</p>
<table style="width:100%; padding:0em; border-spacing:0em;" class="tablef">
<tbody><tr>
<td style="width:30%;" class="td-r"><code>Reverse(pit)</code></td>
<td style="width:35%;" class="td-r">= <code>tReverse(pi)</code></td>
<td style="width:35%;" class="td-r">using <code>else</code> clause</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>tiReverse(p)</code></td>
<td class="td-r">using <code>else</code> clause</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>tiReverse</code>(<i>λ</i><code>p)</code></td>
<td class="td-r">inserting empty string</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>tipReverse</code>(<i>λ</i>)</td>
<td class="td-r">using <code>else</code> clause</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>tip</code><i>λ</i></td>
<td class="td-r">using <code>then</code> clause</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>tip</code></td>
<td class="td-r">removing empty string</td>
</tr>
</tbody></table>
<p class="noindent">The first three evaluations of the <code>Reverse</code> function send us to the <code>else</code> clause, since the parameter <i>s</i> is not the empty string. The evaluation of <code>Reverse</code>(<i>λ</i>), however, uses the nonrecursive <code>then</code> clause, so the calculation bottoms out.</p>
<p class="indentt">We can now revisit the binary search algorithm using recursion. The recursive version of this algorithm works the same way; each recursive call eliminates the half of the remaining array in which <i>t</i> cannot lie. See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>.</p>
<span epub:type="pagebreak" id="page_304"></span>
<p class="linet"></p>
<p class="alg"><a id="ch5algo4"></a><b>Algorithm 5.4</b> Binary Search (recursive).</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: The set <i>U</i> is totally ordered by &lt;, and <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <i>U</i>, with <i>n</i> ≥ 1,</p>
<p class="image"><i>x</i><sub>1</sub> &lt; <i>x</i><sub>2</sub> &lt; … &lt; <i>x<sub>n</sub></i>,</p>
<p class="indent">&nbsp;&nbsp;and <i>t</i> ∈ <i>U</i>. Also, 1 ≤ <i>l</i> ≤ <i>r</i> ≤ <i>n</i>.</p>
<p class="hang3">Postconditions: <code>BinSearch</code>(<i>t, X, l, r</i>) = (<i>t</i> ∈ {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>})</p>
<p class="mathe0"><code>function BinSearch</code>(<i>t</i> ∈ <i>U</i>,</p>
<p class="mathe3">&nbsp;<i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <i>U</i>,</p>
<p class="mathe3">&nbsp;<i>l, r</i> ∈ {1,2, …, <i>n</i>})</p>
<p class="mathe"><i>i</i> ←⌊(<i>l + r</i>)/2⌋</p>
<p class="mathe"><code>if</code> <i>t</i> = <i>x<sub>i</sub></i> <code>then</code></p>
<p class="mathe1"><code>return true</code></p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌜</span> <code>if</code> (<i>t</i> &lt; <i>x<sub>i</sub></i>) ∧ (<i>l</i> &lt; <i>i</i>) <code>then</code></p>
<p class="mathe2a"><code>return BinSearch</code>(<i>t, X, l, i</i> − 1)</p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <code>if</code> (<i>t</i> &gt; <i>x<sub>i</sub></i>) ∧ (<i>i</i> &lt; <i>r</i>) <code>then</code></p>
<p class="mathe2c"><code>return BinSearch</code>(<i>t, X, i</i> + 1, <i>r</i>)</p>
<p class="mathe2b"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌞</span>&nbsp;&nbsp;<span class="mat1">⌞</span>&nbsp;&nbsp;&nbsp;<code>return false</code></p>
<p class="linetb"></p>
<p class="indent">The preconditions of this function are almost exactly the same as the preconditions for <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>. The only difference is the specification of the allowable range for <i>l</i> and <i>r</i>. The postconditions say that the function returns the true/false value of the statement “<i>t</i> ∈ {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>}.” It is a common practice for a testing function like this one to return a true/false value. A typical call to this function would look like this:</p>
<p class="mathet"><code>if BinSearch</code>(<i>t</i>, {3,6,9,12,15}, 1, <i>n</i><code>) then</code></p>
<p class="mathe1"><code>print</code> Element <i>t</i> was found.</p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><code>print</code> Element <i>t</i> was not found.</p>
<p class="noindentt">The choice of 1 and <i>n</i> for the last two parameters tell the function to search the whole array.</p>
<p class="indent">The following top-down evaluation of the recursive binary search looks for the target value 21 in the array <i>X</i> = {3,6,9,12,15,18,21,24,27,30}.</p>
<table style="width:100%; padding:0em; border-spacing:0em;" class="tablef">
<tbody><tr>
<td style="width:40%;" class="td-r"><code>BinSearch</code>(21, <i>X</i>, 1, 10)</td>
<td style="width:60%;" class="td-r">= <code>BinSearch</code>(21, <i>X</i>, 6, 10)</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>BinSearch</code>(21, <i>X</i>, 6, 7)</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>BinSearch</code>(21, <i>X</i>, 7, 7)</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code>true</code></td>
</tr>
</tbody></table>
<p class="indent"><span epub:type="pagebreak" id="page_305"></span>Pay attention to how the values of the parameters <i>l</i> and <i>r</i> change in each recursive function call. First <i>i</i> is chosen to lie in the middle of <i>l</i> and <i>r</i>, then the new values of <i>l</i> and <i>r</i> span either the left or right side of <i>i</i>, depending on where the target must lie. As an exercise, trace through the pseudocode for this algorithm and determine what comparisons are made for each function call in the above calculation.</p>
<p class="border"></p>
<p class="border1"></p>
<p class="h3"><a id="ch5exe1"></a>Exercises 5.1</p>
<p class="numlist">1.&nbsp;&nbsp;In the sequential search of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>, suppose that <i>t</i> = <i>x</i><sub>1</sub> before execution. How many times will the statement</p>
<p class="image"><i>i</i> ← <i>i</i> + 1</p>
<p class="numlistpara1">be executed? Explain.</p>
<p class="numlist">2.&nbsp;&nbsp;Give good preconditions and postconditions for the following pseudocode segment.</p>
<p class="loweralpha1-le"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq305-2.png" alt="Image" width="342" height="133" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq305-2.png"></p>
<p class="numlist">3.&nbsp;&nbsp;Give a postcondition for the following algorithm that completely describes how the final value of <i>i</i> is related to <i>x</i>.</p>
<p class="loweralpha1-le1">Precondition: <i>x</i> is a positive real number.</p>
<p class="loweralpha1-le"><i>i</i> ← 0</p>
<p class="loweralpha1-le"><code>while</code> <i>i</i> &lt; <i>x</i> <code>do</code></p>
<p class="mathe2b"><i>i</i> ← <i>i</i> + 1</p>
<p class="numlist">4.&nbsp;&nbsp;Give a postcondition for the following algorithm that completely describes how the final value of <i>i</i> is related to <i>x</i>.</p>
<p class="loweralpha1-le1">Precondition: <i>x</i> is a positive odd integer.</p>
<p class="loweralpha1-le"><i>i</i> ← 0</p>
<p class="loweralpha1-le"><code>while</code> <i>i</i> &lt; <i>x</i> <code>do</code></p>
<p class="mathe2b"><i>i</i> ← <i>i</i> + 2</p>
<p class="numlist"><span epub:type="pagebreak" id="page_306"></span>5.&nbsp;&nbsp;Give preconditions on the variable <i>t</i> in the following algorithm so that the postcondition holds. Assume <i>x</i> ∈ <b>R</b>.</p>
<p class="loweralpha1-le1">Postcondition: <i>p</i> = <i>xt</i>.</p>
<p class="loweralpha1-le"><i>p</i> ← 0</p>
<p class="loweralpha1-le"><i>i</i> ← 0</p>
<p class="loweralpha1-le"><code>while</code> <i>i</i> &lt; <i>t</i> <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>p</i> ← <i>p</i> + <i>x</i></p>
<p class="numlist">6.&nbsp;&nbsp;Consider <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex3">Example 5.3</a>. If <i>t</i> ∈ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>}, what do the postconditions say must be true about the value of <i>i</i> after execution? What derivation rules from propositional logic can you use to justify your answer?</p>
<p class="numlist">7.&nbsp;&nbsp;Consider <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>. Rewrite the postconditions as an implication (<i>p</i> ⇒ <i>q</i>) using an equivalence rule from propositional logic.</p>
<p class="numlist">8.&nbsp;&nbsp;Consider the following pseudocode function.</p>
<p class="loweralpha1-le"><code>function W</code>(<i>n</i> ∈ <b>Z</b>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> &gt; 0 <code>then</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <code>if</code> <i>n</i> <code>is odd then</code></p>
<p class="mathe3"><code>return</code> 2<i>n</i></p>
<p class="mathe2c"><code>else</code></p>
<p class="mathe2b"><span class="mat1">⌞</span> <code>return</code> <i>n</i> + 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> <i>n</i> − 1</p>
<p class="numlistpara1">Compute the values returned by the following function calls.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;<code>W</code>(10)</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;<code>W</code>(−21)</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;<code>W</code>(7)</p>
<p class="numlist">9.&nbsp;&nbsp;Let <i>T</i> be a binary search tree whose data can be compared using &lt;. Consider the following algorithm.</p>
<p class="loweralpha1-le">Precondition: Some node in <i>T</i> contains value <i>t</i>.</p>
<p class="loweralpha1-le"><i>l</i> ← 0</p>
<p class="loweralpha1-le"><i>x</i> ← <code>the root of</code> <i>T</i></p>
<p class="loweralpha1-le"><code>while</code> <i>x</i> ≠ <i>t</i></p>
<p class="mathe2b"><span class="mat1">⌜</span> <code>if</code> <i>x</i> &lt; <i>t</i> <code>then</code></p>
<p class="mathe2d"><i>x</i> ← <i>x</i><code>’s right child</code></p>
<p class="mathe2c"><code>else</code></p>
<p class="mathe2d"><i>x</i> ← <i>x</i><code>’s left child</code></p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>l</i> ← <i>l</i> + 1</p>
<p class="numlistpara1">Give a postcondition that accurately describes the value of <i>l</i>.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_307"></span>10.&nbsp;&nbsp;Consider the following algorithm</p>
<p class="mathet">&nbsp;Preconditions: <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <b>N</b>.</p>
<p class="mathe2t"><i>i</i> ← 1</p>
<p class="mathe2"><i>t</i> ← 0</p>
<p class="mathe2"><code>while</code> <i>i</i> ≤ <i>n</i> <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>s</i> ← 1</p>
<p class="mathe2c"><i>j</i> ← 1</p>
<p class="mathe2c"><code>while</code> <i>j</i> ≤ <i>i</i> <code>do</code></p>
<p class="mathe3"><span class="mat1">⌜</span> <i>s</i> ← <i>s</i> · <i>x<sub>i</sub></i></p>
<p class="mathe3"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2c"><i>t</i> ← <i>t</i> + <i>s</i></p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="loweralpha1">(a)&nbsp;&nbsp;Give a postcondition that accurately describes the value of <i>t</i>.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Compute the number of times the algorithm performs a multiplication operation (in terms of <i>n</i>).</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Give a big-Θ estimate of your answer to part (b).</p>
<p class="numlistm">11.&nbsp;&nbsp;Trace through <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>, given <i>X</i> = {3,6,10,14,20,23} and <i>t</i> = 20. Give a table showing the values of <i>i, l</i>, and <i>r</i> every time they change, along with any <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-1.png" alt="Image" width="18" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-1.png"> and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-2.png" alt="Image" width="19" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-2.png"> comparisons.</p>
<p class="numlistm">12.&nbsp;&nbsp;Consider the following pseudocode function.</p>
<p class="mathe2t"><code>function Crunch</code>(<i>x</i> ∈ <b>R</b>)</p>
<p class="mathe2a"><code>if</code> <i>x</i> ≥ 100 <code>then</code></p>
<p class="mathe2b"><code>return</code> <i>x</i>/100</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> <i>x</i> + <code>Crunch</code>(10 · <i>x</i>)</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Compute <code>Crunch</code>(137).</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Compute <code>Crunch</code>(53).</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Compute <code>Crunch</code>(4).</p>
<p class="loweralpha1">(d)&nbsp;&nbsp;What happens if you try to compute <code>Crunch</code>(−26)? What does this suggest about an appropriate precondition for this function?</p>
<p class="numlistm">13.&nbsp;&nbsp;Look at the top-down evaluation of <code>BinSearch</code>(21, <i>X</i>, 1, 10) that follows <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>. For each function call in this evaluation, give the value of <i>i</i> and say what <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-1.png" alt="Image" width="18" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-1.png">, <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-2.png" alt="Image" width="19" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-2.png">, and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-3.png" alt="Image" width="20" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-3.png"> comparisons of list elements are made.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_308"></span>14.&nbsp;&nbsp;Consider <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>. Evaluate</p>
<p class="image"><code>BinSearch</code>(7, {2,4,6,8},1,4)</p>
<p class="numlistpara1">using a top-down evaluation.</p>
<p class="numlistm">15.&nbsp;&nbsp;Consider <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>. Let <i>X</i> = {3,6,9,12,15,18,21,24,27,30}. Evaluate</p>
<p class="image"><code>BinSearch</code>(3, <i>X</i>,1,10)</p>
<p class="numlistpara1">using a top-down evaluation.</p>
<p class="numlistm">16.&nbsp;&nbsp;Consider the string reversal algorithm in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex6">Example 5.6</a>. Evaluate</p>
<p class="image"><code>Reverse(prewt)</code></p>
<p class="numlistpara1">using a top-down evaluation.</p>
<p class="numlistm">17.&nbsp;&nbsp;Trace through the following algorithm, if it is invoked as <code>GCD</code>(42,24). Use a top-down evaluation. (Recall that “<i>n</i> mod <i>m</i>” is the remainder when <i>n</i> is divided by <i>m</i>.)</p>
<p class="mathe2t"><code>function GCD</code>(<i>m, n</i> ∈ {0,1,2,3, …})</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 0 <code>then</code></p>
<p class="mathe2b"><code>return</code> <i>m</i></p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return GCD</code>(<i>n, m</i> mod <i>n</i>)</p>
<p class="numlistm">18.&nbsp;&nbsp;The following is known as the Ackermann function.</p>
<p class="mathe2t"><code>function Ack</code>(<i>m, n</i> ∈ {0,1,2,3, …})</p>
<p class="mathe2a"><code>if</code> <i>m</i> = 0 <code>then</code></p>
<p class="mathe2b"><code>return</code> <i>n</i> + 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <code>if</code> <i>n</i> = 0 <code>then</code></p>
<p class="mathe2d"><code>return Ack</code>(<i>m</i> − 1,1)</p>
<p class="mathe2c"><code>else</code></p>
<p class="mathe2b"><span class="mat1">⌞</span>&nbsp;&nbsp;&nbsp;<code>return Ack</code>(<i>m</i> − 1, <code>Ack</code>(<i>m, n</i> − 1<code>))</code></p>
<p class="numlistpara1">Compute the values returned by the following function calls.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;<code>Ack</code>(0,7)</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;<code>Ack</code>(1,0)</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;<code>Ack</code>(1,1)</p>
<p class="loweralpha1">(d)&nbsp;&nbsp;<code>Ack</code>(2,1)</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_309"></span>19.&nbsp;&nbsp;Write a pseudocode segment that is equivalent to</p>
<p class="mathet">&nbsp;&nbsp;&nbsp;&nbsp;<code>for</code> <i>i</i> ∈ {1,2,3, …, <i>n</i>} <code>do</code></p>
<p class="mathe2b"><code>print "YADA"</code></p>
<p class="numlistpara1">using a <code>while</code>-loop instead of a <code>for</code>-loop.</p>
<p class="numlistm">20.&nbsp;&nbsp;Rewrite the bubble sort (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo2">Algorithm 5.2</a>) using nested <code>while</code>-loops instead of nested <code>for</code>-loops.</p>
<p class="numlistm">21.&nbsp;&nbsp;Write an iterative algorithm in pseudocode that satisfies the following preconditions and postconditions.</p>
<p class="numlistpara1">Preconditions: <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>}, <i>Y</i> = {<i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>n</sub></i>} are subsets of <b>N</b>. Postconditions: <i>k</i> = | <i>X</i> ∩ <i>Y</i>|.</p>
<p class="numlistm">22.&nbsp;&nbsp;Write a recursive function in pseudocode that computes the value of the following recurrence relation:</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq309-1.png" alt="Image" width="497" height="78" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq309-1.png"></p>
<p class="numlistpara1">Give descriptive preconditions and postconditions. (Hint: See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3ex10">Example 3.10</a>.)</p>
<p class="numlistm">23.&nbsp;&nbsp;See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3def1">Definition 3.1</a> on page 154. Translate the recurrence relation for the Fibonacci numbers <i>F</i>(<i>n</i>) directly into pseudocode. Perform a top-down evaluation of <i>F</i>(6). (Note: If you do the top-down evaluation correctly, you will find yourself writing down some redundant calculations.)</p>
<p class="numlistm">24.&nbsp;&nbsp;Write an iterative algorithm to compute <i>F</i>(<i>n</i>), the <i>n</i>th Fibonacci number.</p>
<p class="numlistm">25.&nbsp;&nbsp;Write a pseudocode version of the factorial function …</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;iteratively.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;recursively.</p>
<p class="h1"><a id="ch5sub2"></a><b>5.2&nbsp;&nbsp;&nbsp;Three Common Types of Algorithms</b></p>
<p class="noindent">To the uninitiated, birdwatching might seem somewhat pointless. What is so fun about learning the difference between a junco and a chickadee, or distinguishing among the various species of hawks? But once you start trying to identify birds, you start noticing new things about them. The simple task of classification forces you to consider subtle differences in structure and behavior, and this leads to greater understanding and appreciation of these creatures.</p>
<p class="indent"><span epub:type="pagebreak" id="page_310"></span>In any scholarly pursuit, classifying objects supports the learning process. In this section we investigate three specific types of algorithms: traversal algorithms, greedy algorithms, and divide-and-conquer algorithms. While this list is by no means exhaustive, these three families of algorithms will provide some context for thinking about problems analytically.</p>
<div class="box">
<p class="noindent1"><b>Inquiry 5.3</b> A circular garden has the following design. Describe a method for walking through the garden, starting and ending in the center, in such a way that you travel along all its paths. Try to backtrack as little as possible. Does your method generalize to a larger garden with more rings in the same pattern?</p>
<p class="image-2"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig310-1.png" alt="Image" width="198" height="199" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig310-1.png"></p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.4</b> Claude and Maude are playing a game with poker chips. The object of the game is to draw the last chip. The players take turns drawing chips. At each turn, a player must take at least 1 chip and at most 10 chips. Claude goes first. What is an optimal strategy? Does the strategy depend on the number of chips left?</p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.5</b> An elementary school teacher needs to line up his class of 16 students in order of height. From experience, he knows his students are incapable of doing this on their own. However, when divided into groups of four, they can reliably sort themselves in order of height. What can this teacher do?</p>
</div>
<p class="h2"><a id="ch5sub2sub1"></a><b>5.2.1&nbsp;&nbsp;&nbsp;Traversal Algorithms</b></p>
<p class="noindent">Data is usually arranged in some sort of structure. In order to do anything with the data—search it, print it out, manipulate it—you must be able to go through the data structure in some systematic way. An algorithm that does this is called a <i>traversal algorithm</i>. Think of the job of a traversal algorithm as executing the generic statement</p>
<p class="image"><code>visit</code> <i>x</i></p>
<p class="noindent">for every element <i>x</i> in the data structure.</p>
<p class="indent">For example, a <code>for</code>-loop is all you need to traverse the elements of an array <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>.</p>
<p class="mathet"><code>for</code> <i>i</i> ∈ {1,2, …, <i>n</i>} <code>do</code></p>
<p class="mathe1">&nbsp;<code>visit</code> <i>x<sub>i</sub></i></p>
<p class="noindentt"><span epub:type="pagebreak" id="page_311"></span>Similarly, the nested <code>for</code>-loops of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex49">Example 4.49</a> execute a traversal through a Cartesian product of sets. In fact, we can regard any of the enumeration algorithms in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4sub5">Section 4.5</a> as traversal algorithms; in order to get an accurate count of the elements in a set, an algorithm must <code>visit</code> each element exactly once.</p>
<p class="indent">More complicated data structures require more interesting traversal algorithms. Recall that a <i>binary tree</i> is a tree with a designated root in which each node has, at most, two children: a left child and a right child. Since binary trees are recursive structures, we can think of the left and right children as roots of binary subtrees. Thinking recursively suggests that a traversal of a binary tree should traverse each subtree and also visit the root. Choosing different orders for these tasks leads to the three standard ways to traverse a binary tree: the preorder, postorder, and inorder traversals (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo5">Algorithms 5.5</a>, <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo6">5.6</a>, and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo7">5.7</a>, respectively).</p>
<p class="indent">We use a <code>return</code> statement without a value to indicate the end of the function. A function that doesn’t return a value is sometimes called a <i>procedure</i> or <i>subroutine</i>. We are also “abusing” notation by representing the empty tree with the <span class="a1">∅</span> symbol. We studied the inorder traversal in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3sub5">Section 3.5</a>, where we viewed it as a mathematical function.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo5"></a><b>Algorithm 5.5</b> Preorder Traversal.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>T</i> is a binary tree.</p>
<p class="hang3">Postconditions: Every node of <i>T</i> was visited exactly once.</p>
<p class="mathet"><code>function PreOrder</code>(<i>T</i> ∈ {<code>binary trees</code>})</p>
<p class="mathe1"><code>if</code> <i>T</i> ≠ <span class="a1">∅</span> <code>then</code></p>
<p class="mathe2"><code>visit the root of</code> <i>T</i></p>
<p class="mathe2"><code>PreOrder</code>(<i>T</i>’<code>s left subtree)</code></p>
<p class="mathe2"><code>PreOrder</code>(<i>T</i>’<code>s right subtree)</code></p>
<p class="mathe1"><code>return</code></p>
<p class="linetb"></p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo6"></a><b>Algorithm 5.6</b> Postorder Traversal.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>T</i> is a binary tree.</p>
<p class="hang3">Postconditions: Every node of <i>T</i> was visited exactly once.</p>
<p class="mathet"><code>function PostOrder</code>(<i>T</i> ∈ {<code>binary trees</code>})</p>
<p class="mathe1"><code>if</code> <i>T</i> ≠ <span class="a1">∅</span> <code>then</code></p>
<p class="mathe2"><code>PostOrder</code>(<i>T</i>’<code>s left subtree</code>)</p>
<p class="mathe2"><code>PostOrder</code>(<i>T</i>’<code>s right subtree</code>)</p>
<p class="mathe2"><code>visit the root of</code> <i>T</i></p>
<p class="mathe1"><code>return</code></p>
<p class="linetb"></p>
<p class="linet"></p>
<p class="alg"><span epub:type="pagebreak" id="page_312"></span><a id="ch5algo7"></a><b>Algorithm 5.7</b> Inorder Traversal.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>T</i> is a binary tree.</p>
<p class="hang3">Postconditions: Every node of <i>T</i> was visited exactly once.</p>
<p class="mathet"><code>function InOrder</code>(<i>T</i> ∈ {<code>binary trees</code>})</p>
<p class="mathe1"><code>if</code> <i>T</i> ≠ <span class="a1">∅</span> <code>then</code></p>
<p class="mathe2"><code>InOrder</code>(<i>T</i>’<code>s left subtree</code>)</p>
<p class="mathe2"><code>visit the root of</code> <i>T</i></p>
<p class="mathe2"><code>InOrder</code>(<i>T</i>’<code>s right subtree</code>)</p>
<p class="mathe1"><code>return</code></p>
<p class="linetb"></p>
<p class="noindentt"><a id="ch5ex7"></a><span class="blue"><b>Example 5.7</b></span> Do a preorder, postorder, and inorder traversal on the tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig2">Figure 5.2</a>.</p>
<p class="noindentt"><i>Solution:</i> Tracing through these algorithms is a little tricky, but the resulting patterns are easy to recognize. Let <i>L</i> represent the subtree with root “complexify,” and leaves “clueless” and “jazzed,” and let <i>R</i> be the subtree with root “poset,” and leaves “phat” and “sheafify.” Then we can trace through the recursive function as follows, using indentation to show successive recursive calls (see <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig3">Figure 5.3</a>).</p>
<p class="indent">Notice that every nontrivial call to <code>PreOrder</code> spawns a <code>visit</code> followed by two more calls to <code>PreOrder</code>. The recursion bottoms out when <code>PreOrder</code>(<span class="a1">∅</span>) is called, since the function skips the <code>then</code> clause for this value of the parameter. Therefore the preorder traversal visits the nodes in the following order.</p>
<p class="blockquote">macchiato, complexify, clueless, jazzed, poset, phat, sheafify.</p>
<p class="noindent">A postorder traversal runs through</p>
<p class="blockquote">clueless, jazzed, complexify, phat, sheafify, poset, macchiato</p>
<p class="noindent">and an inorder traversal yields</p>
<p class="blockquote">clueless, complexify, jazzed, macchiato, phat, poset, sheafify.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig312-1.png" alt="Image" width="632" height="199" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig312-1.png"></p>
<p class="figcaption"><a id="ch5fig2"></a><b><span class="blue">Figure 5.2</span></b> A binary tree.</p>
</div>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_313"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig313-1.png" alt="Image" width="613" height="793" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig313-1.png"></p>
<p class="figcaption"><a id="ch5fig3"></a><b><span class="blue">Figure 5.3</span></b></p>
</div>
<p class="noindent">We’ll leave it as an exercise to write a detailed trace of the postorder and inorder traversals.</p>
<p class="right">◊</p>
<p class="indentt">To compare these three ways of traversing a tree, imagine making a path around the outside of the tree, as shown in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig4">Figure 5.4</a>. All three traversal algorithms make their visits along roughly similar paths; the differences lie in the order of the visits. In a preorder traversal, the parent is always visited before the children, while in a postorder, the children are always visited before the parent. <span epub:type="pagebreak" id="page_314"></span>An inorder traversal visits the parent after visiting all of the left descendants and before visiting any of the right descendants.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig313-2.png" alt="Image" width="1041" height="186" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig313-2.png"></p>
<p class="figcaptionj"><a id="ch5fig4"></a><b><span class="blue">Figure 5.4</span></b> All three tree traversal algorithms follow a path around the outside of the tree, but they differ in when they visit each node.</p>
</div>
<p class="indent">In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3sub5">Section 3.5</a>, we made the observation that, for binary search trees, an inorder traversal visits all the nodes in order. In the exercises we’ll discuss some applications of the preorder and postorder traversals.</p>
<p class="h2"><a id="ch5sub2sub2"></a><b>5.2.2&nbsp;&nbsp;&nbsp;Greedy Algorithms</b></p>
<p class="noindent">Some things require planning. Even novice chess players know that capturing pieces whenever possible is not the way to win a game; a winning strategy requires thinking about the long term. On the other hand, maximizing the amount of candy you get when a piñata breaks is a much simpler task: just grab the most you can whenever you can. The latter strategy is a type of <i>greedy algorithm</i>. These types of algorithms accomplish a long-term goal by doing the most obvious short-term task at every opportunity.</p>
<p class="indent">In the United States, Canada, and several other countries, the most commonly used coins come in values of 1, 5, 10, and 25. Consider the problem of forming <i>N</i> cents using pennies (1<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png">), nickels (5<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png">), dimes (10<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png">), and quarters (25<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png">). We would normally like to have our change in as few coins as possible; for example, we prefer to have 30<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png"> as a nickel and a quarter (5+25) rather than as three dimes (10+10+10). A greedy algorithm for making change chooses a sequence of coins by taking the largest denomination at each step (see <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo8">Algorithm 5.8</a>).</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo8"></a><b>Algorithm 5.8</b> Making Change.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>N</i> ∈ <b>N</b>, 1 ≤ <i>N</i> ≤ 100.</p>
<p class="hang3">Postconditions: <i>p</i>+5<i>n</i>+10<i>d</i>+25<i>q</i>=<i>N</i>, and <i>p</i>+ <i>n</i>+<i>d</i>+<i>q</i> is as small as possible.</p>
<p class="mathet"><i>p, n, d, q</i> ← 0</p>
<p class="mathe"><i>T</i> ← <i>p</i> + 5<i>n</i> + 10<i>d</i> + 25<i>q</i></p>
<p class="mathe"><code>while</code> <i>T</i> &lt; <i>N</i> <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <code>if</code> <i>N</i> – <i>T</i> ≥ 25 <code>then</code></p>
<p class="mathe2b"><i>q</i> ← <i>q</i> + 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>if</code> <i>N</i> – <i>T</i> ≥ 10 <code>then</code></p>
<p class="mathe2c"><i>d</i> ← <i>d</i> + 1</p>
<p class="mathe2b"><code>else</code></p>
<p class="mathe2c"><code>if</code> <i>N</i> – <i>T</i> ≥ 5 <code>then</code></p>
<p class="mathe2d"><i>n</i> ← <i>n</i> + 1</p>
<p class="mathe2c"><code>else</code></p>
<p class="mathe2d"><i>p</i> ← <i>p</i> + 1</p>
<p class="mathe2"><span class="mat1">⌞</span> <i>T</i> ← <i>p</i> + 5<i>n</i> + 10<i>d</i> + 25<i>q</i></p>
<p class="linetb"></p>
<p class="indent"><span epub:type="pagebreak" id="page_315"></span>The variable <i>N</i> represents the desired monetary value of change, while the indices <i>p, n, d, q</i> store running counts of the number of pennies, nickels, dimes, and quarters. At the end of each time through the loop, <i>T</i> is updated to give the monetary value of a collection of <i>p</i> pennies, <i>n</i> nickels, <i>d</i> dimes, and <i>q</i> quarters. Therefore <i>N</i> − <i>T</i> represents the discrepancy between the desired value of change and the current value of this collection. The nested <code>if</code>…<code>then</code> …<code>else</code> statements simply decide on the largest possible coin that is less than or equal to the difference <i>N</i> − <i>T</i>, and update the appropriate index.</p>
<p class="indent">It isn’t obvious that this algorithm always gives an optimal amount of change. For example, suppose that dimes were worth 20<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png"> instead of 10<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png">. The optimal way to make 40<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png"> would be to use two of these “dimes” (20+20) but a greedy algorithm would take four coins: a quarter and three nickels (25 + 5 + 5 + 5). For standard U.S. currency, <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo8">Algorithm 5.8</a> does minimize the number of coins, but the proof of this fact is a little messy. Our “20<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in314-1.png" alt="Image" width="12" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in314-1.png"> dime” scenario suggests that the argument must rely on the relationship between 1, 5, 10, and 25.</p>
<p class="indent">Another classic application of greedy algorithms involves finding a minimal spanning tree in a network. Recall that a network is a graph with numerical weights on each edge. Given a network <i>N</i>, it is often helpful to construct a connected subgraph <i>T</i> of <i>N</i> such that <i>T</i> spans all the vertices of <i>N</i> while the edges of <i>T</i> have the least possible total weight. Such a subgraph is called a <i>minimal spanning tree</i>. Note that any such <i>T</i> would have to be a tree, since any circuit would contain an unnecessary edge. The question is, which edges should we include? It turns out that a greedy algorithm will always give us the best tree. See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo9">Algorithm 5.9</a>.</p>
<p class="indent">This algorithm makes the “greedy” choice of the shortest possible edge at every opportunity. (If there is a tie for the length of the shortest edge, any one of the shortest edges can be chosen.) The postconditions make three claims about the resulting tree <i>T</i>: it spans all the vertices, it is a tree, and it has minimal total weight. The first two claims are easy to verify; each new edge will never add a circuit, and the <code>while</code>-loop will not finish until all the vertices of <i>N</i> are in <i>T</i>. For the sake of brevity, we omit the proof that <i>T</i> is minimal, but it always is.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo9"></a><b>Algorithm 5.9</b> Prim’s Algorithm for constructing a minimal spanning tree.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>N</i> is a connected network.</p>
<p class="hang3">Postconditions: <i>T</i> is a minimal spanning tree of <i>N</i>.</p>
<p class="mathet"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq315-1.png" alt="Image" width="176" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq315-1.png">, <code>where</code> <i>e</i><sub>1</sub> <code>is the shortest edge of</code> <i>N</i>.</p>
<p class="mathe"><code>while</code> <i>T</i> <code>does not contain all of</code> <i>N</i>’<code>s vertices</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>e</i> ← <code>the shortest edge between a vertex in</code> <i>T</i></p>
<p class="mathe2c"><code>and a vertex not in</code> <i>T</i>.</p>
<p class="mathe2"><span class="mat1">⌞</span> <code>Add edge</code> <i>e</i> <code>and the new vertex to</code> <i>T</i>.</p>
<p class="linetb"></p>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_316"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig316-1.png" alt="Image" width="371" height="346" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig316-1.png"></p>
<p class="figcaption"><a id="ch5fig5"></a><b><span class="blue">Figure 5.5</span></b> A network showing mileage between cities.</p>
</div>
<p class="noindentt"><span class="blue"><b>Example 5.8</b></span> In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/08_Chapter02.xhtml#ch2exa4">Example 2.4</a>, we constructed a network showing the driving distances between several California cities. This network is shown in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig5">Figure 5.5</a>. Suppose we are given the task of laying fiber-optic cable along these roads in such a way that all of these cities are connected. How can this be done with as little cable as possible?</p>
<p class="noindentt"><i>Solution:</i> To minimize the amount of cable and still connect all the cities, we need a minimal spanning tree. Using <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo9">Algorithm 5.9</a>, we begin with <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in316-1.png" alt="Image" width="151" height="29" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in316-1.png"> because <i>LB</i> is the edge with least weight. Looking at all the edges on <i>L</i> and all the edges on <i>B</i> reveals that <i>LS</i> is the edge with least weight, so we add it and its vertex to <i>T</i>. Then after adding <i>BN, LF</i>, and <i>EF</i>, we have included all the vertices, so the minimal spanning tree <i>T</i> uses the edges <i>LB, LS, BN, LF</i>, and <i>EF</i>. The final tree (and hence the optimal layout of the cable network) is shown in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig6">Figure 5.6</a>. Its total weight is 1055; this is the least number of miles of cable needed to connect all the cities.</p>
<p class="right">◊</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig316-2.png" alt="Image" width="371" height="346" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig316-2.png"></p>
<p class="figcaptionj"><a id="ch5fig6"></a><b><span class="blue">Figure 5.6</span></b> A minimal spanning tree for the network in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig5">Figure 5.5</a>.</p>
</div>
<p class="h2"><a id="ch5sub2sub3"></a><span epub:type="pagebreak" id="page_317"></span><b>5.2.3&nbsp;&nbsp;&nbsp;Divide-and-Conquer Algorithms</b></p>
<p class="noindent">The recursive version of the binary search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>) works by dividing the list in half and calling itself recursively on each part. After enough divisions the list is small enough (one element) for the base case to apply. The recursive binary search is an example of a <i>divide-and-conquer</i> algorithm. This type of recursive algorithm divides the given problem (usually in half) and attempts to solve each part. Since the successive divisions rapidly become small, divide-and-conquer algorithms tend to work quickly.</p>
<p class="indent">The following is a recursive alternative to <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex54">Example 4.54</a> of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4sub5">Section 4.5</a>. If you keep the divide-and-conquer paradigm in mind, it is easy to see how to define the function.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo10"></a><b>Algorithm 5.10</b> Finding the largest element in a list.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} is a set of elements on which <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in122-1.png" alt="Image" width="18" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in122-1.png"> defines a total ordering.</p>
<p class="hang3">Postconditions: <code>FindMax</code>(<i>X</i>) = max{<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>}.</p>
<p class="mathet"><code>function FindMax</code>(<i>X</i>)</p>
<p class="mathe1"><code>if</code> <i>X</i> = {<i>x</i>} <code>then</code></p>
<p class="mathe2"><code>return</code> <i>x</i></p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><i>a</i> ← <code>FindMax</code>({<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub>⌊<i>n</i>/2⌋</sub>})</p>
<p class="mathe2"><i>b</i> ← <code>FindMax</code>({<i>x</i><sub>⌊<i>n</i>/2⌋+1</sub>, …, <i>x<sub>n</sub></i>})</p>
<p class="mathe2"><code>if</code> <i>a</i> ≺ <i>b</i> <code>then</code></p>
<p class="mathe2a"><code>return</code> <i>b</i></p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><code>return</code> <i>a</i></p>
<p class="linetb"></p>
<p class="indent">A binary tree is a natural model for tracing the execution of a divide-and-conquer algorithm. Each node represents a function call, and the children of a node <i>X</i> represent the recursive calls made by <i>X</i>. The labels on each edge represent the return value of the lower node. When you draw such a tree, you start with the original call at the root and work down, and once you have drawn all the nodes you can start filling in the labels/return values from the bottom up.</p>
<p class="indent"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig7">Figure 5.7</a> shows such a tree. The first call to <code>FindMax</code>({5,3,2,4}) spawns two recursive calls: <code>FindMax</code>({5,3}) and <code>FindMax</code>({2,4}). These in turn each make two calls to <code>FindMax</code>{<i>n</i>} for some <i>n</i>, and since each of these parameter values is a set of the form {<i>n</i>}, each call returns <i>n</i>. When 5 and 3 are returned to the <code>FindMax</code>({5,3}) call, it makes the comparison 5 <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in317-1.png" alt="Image" width="18" height="33" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in317-1.png"> 3 and returns 5. Similarly, <code>FindMax</code>({2,4}) makes the comparison 2 <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in317-1.png" alt="Image" width="18" height="33" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in317-1.png"> 4 and returns 4. Finally, the original <code>FindMax</code>({5,3,2,4}) call compares 5 <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in317-1.png" alt="Image" width="18" height="33" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in317-1.png"> 4 and returns 5, the maximum value in the set. Notice that the divide-and-conquer approach to finding the maximum element makes different comparisons than the iterative version in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex54">Example 4.54</a>.</p>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_318"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig318-1.png" alt="Image" width="947" height="265" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig318-1.png"></p>
<p class="figcaption"><a id="ch5fig7"></a><b><span class="blue">Figure 5.7</span></b> A binary tree models the trace of <code>FindMax</code>({5, 3, 2, 4}).</p>
</div>
<p class="indent">The divide-and-conquer paradigm leads to a nice algorithm for sorting the elements <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> in an array. In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4sub5">Section 4.5</a>, we studied the bubble sort. This simple algorithm works well for small arrays, but it can be rather slow for large sets of data. The <i>merge sort</i> works more efficiently by dividing and conquering.</p>
<p class="indent">The main idea behind the merge sort is simple: divide the array into two smaller arrays, sort the smaller arrays (recursively), and merge the smaller arrays back together. The tricky part is the merging process, which is done by <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo11">Algorithm 5.11</a>.</p>
<p class="indent">We’ll take a closer look at this algorithm in the next section; it really isn’t as complicated as it might look at first glance. For now, just accept that it takes two ordered arrays and puts them together to make one big ordered array. Once you have this procedure for merging two ordered arrays, the merge sort is simple to write down using the divide-and-conquer paradigm. See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo12">Algorithm 5.12</a>.</p>
<p class="indent">We can trace the merge sort with a top-down evaluation. To make things interesting, let’s see what it does with a seven-element array with values 12, 3, 5, 17, 2, 8, 9.</p>
<p class="mathe1t"><code>MergeSort</code>(12,3,5,17,2,8,9)</p>
<p class="mathe"><code>= Merge(MergeSort</code>(12,3,5), <code>MergeSort</code>(17,2,8,9<code>))</code></p>
<p class="mathe"><code>= Merge(Merge(MergeSort</code>(12), <code>MergeSort</code>(3,5<code>))</code>,</p>
<p class="mathe2a">&nbsp;&nbsp;<code>Merge(MergeSort</code>(17,2), <code>MergeSort</code>(8,9<code>)))</code></p>
<p class="mathe"><code>= Merge(Merge</code>(12,</p>
<p class="mathe2d"><code>Merge(MergeSort</code>(3), <code>MergeSort</code>(5<code>)))</code>,</p>
<p class="mathe2a">&nbsp;&nbsp;&nbsp;<code>Merge(Merge(MergeSort</code>(17), <code>MergeSort</code>(2<code>))</code>,</p>
<p class="mathe2d">&nbsp;&nbsp;<code>Merge(MergeSort</code>(8), <code>MergeSort</code>(9<code>))))</code></p>
<p class="mathe"><code>= Merge(Merge</code>(12, <code>Merge</code>(3, 5<code>))</code>,</p>
<p class="mathe2a">&nbsp;&nbsp;&nbsp;<code>Merge(Merge</code>(17, 2), <code>Merge</code>(8, 9<code>)))</code></p>
<p class="mathe"><code>= Merge(Merge</code>(12, (3,5)), <code>Merge</code>((2,17), (8,9)<code>))</code></p>
<p class="mathe"><code>= Merge</code>((3,5,12), (2,8,9,17))</p>
<p class="mathe"><code>=</code> 2,3,5,8,9,12,17</p>
<p class="linet"></p>
<p class="alg"><span epub:type="pagebreak" id="page_319"></span><a id="ch5algo11"></a><b>Algorithm 5.11</b> Merge Subroutine.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>l</sub>, z</i><sub>1</sub>, <i>z</i><sub>2</sub>, …, <i>z<sub>m</sub></i> ∈ <i>U, U</i> is totally ordered by &lt;, <i>y</i><sub>1</sub> ≤ <i>y</i><sub>2</sub> ≤ ··· ≤ <i>y<sub>l</sub></i>, and <i>z</i><sub>1</sub> ≤ <i>z</i><sub>2</sub> ≤ ··· ≤ <i>z<sub>m</sub></i>.</p>
<p class="hang3">Postconditions: Returns <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>, where <i>n</i> = <i>l</i> + <i>m, x</i><sub>1</sub> ≤ <i>x</i><sub>2</sub> ≤ ··· ≤ <i>x<sub>n</sub></i>, and {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} = {<i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>l</sub>, z</i><sub>1</sub>, <i>z</i><sub>2</sub>, …, <i>z<sub>m</sub></i>}.</p>
<p class="mathet"><code>function Merge</code>(<i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>l</sub>, z</i><sub>1</sub>, <i>z</i><sub>2</sub>, …, <i>z<sub>m</sub></i> ∈ <i>U</i>)</p>
<p class="mathe1"><i>i</i> ← 1, <i>j</i> ← 1, <i>k</i> ← 1</p>
<p class="mathe1"><code>while</code> <i>k</i> ≤ <i>l</i> + <i>m</i> <code>do</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <code>if</code> <i>i</i> &gt; <i>l</i> <code>then</code></p>
<p class="mathe2c"><span class="mat1">⌜</span> <i>x<sub>k</sub></i> ← <i>z<sub>j</sub></i></p>
<p class="mathe2c"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2a">&nbsp;&nbsp;<code>else if</code> <i>j</i> &gt; <i>m</i> <code>then</code></p>
<p class="mathe2d"><span class="mat1">⌜</span> <i>x<sub>k</sub></i> ← <i>y<sub>i</sub></i></p>
<p class="mathe2d"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2c"><code>else if</code> <i>y<sub>i</sub></i> ← <i>z<sub>j</sub></i> <code>then</code></p>
<p class="mathe2e"><span class="mat1">⌜</span> <i>x<sub>k</sub></i> ← <i>y<sub>i</sub></i></p>
<p class="mathe2e"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2d"><code>else</code></p>
<p class="mathe2e"><span class="mat1">⌜</span> <i>x<sub>k</sub></i> ← <i>z<sub>j</sub></i></p>
<p class="mathe2e"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2a"><span class="mat1">⌞</span> <i>k</i> ← <i>k</i> + 1</p>
<p class="mathe1"><code>return</code> <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>l+m</sub></i></p>
<p class="linetb"></p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo12"></a><b>Algorithm 5.12</b> Merge Sort.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> ∈ <i>U</i>, a set that is totally ordered by &lt;.</p>
<p class="hang3">Postconditions: Returns <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in319-1.png" alt="Image" width="147" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in319-1.png">, where <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in319-2.png" alt="Image" width="165" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in319-2.png"> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in319-3.png" alt="Image" width="212" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in319-3.png"></p>
<p class="mathet"><code>function MergeSort</code>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> ∈ <i>U</i>)</p>
<p class="mathe1"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2"><code>return</code> <i>x</i><sub>1</sub></p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><i>l</i> ← ⌊<i>n</i>/2⌋</p>
<p class="mathe2"><code>return Merge(MergeSort</code>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>l</sub></i>),</p>
<p class="mathe2e">&nbsp;<code>MergeSort</code>(<i>x</i><sub><i>l</i>+1</sub>, <i>x</i><sub><i>l</i>+2</sub>, …, <i>x<sub>n</sub></i><code>))</code></p>
<p class="linetb"></p>
<p class="noindent"><span epub:type="pagebreak" id="page_320"></span>In the next section we will show that the merge sort is more efficient than the bubble sort. In fact, in a certain sense, you will never find a faster sorting algorithm. We’ll see a mathematical reason why in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub4">Section 5.4</a>.</p>
<p class="border"></p>
<p class="border1"></p>
<p class="h3"><a id="ch5exe2"></a>Exercises 5.2</p>
<p class="numlist">1.&nbsp;&nbsp;List the order in which the nodes are visited for (a) a preorder traversal, (b) a postorder traversal, and (c) an inorder traversal of the tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig8">Figure 5.8</a>.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig320-1.png" alt="Image" width="551" height="281" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig320-1.png"></p>
<p class="figcaption"><a id="ch5fig8"></a><b><span class="blue">Figure 5.8</span></b> The binary tree for Exercise 1.</p>
</div>
<p class="numlist">2.&nbsp;&nbsp;Make three copies of the tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig9">Figure 5.9</a> and draw paths that indicate the order in which the nodes are visited for (a) a preorder traversal, (b) a postorder traversal, and (c) an inorder traversal.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig320-2.png" alt="Image" width="456" height="293" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig320-2.png"></p>
<p class="figcaption"><a id="ch5fig9"></a><b><span class="blue">Figure 5.9</span></b> The binary tree for Exercises 2, 3, and 4.</p>
</div>
<p class="numlist">3.&nbsp;&nbsp;Refer to the tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig9">Figure 5.9</a>. Suppose each node of the tree represents a task, and each child node represents a task that must be done before the parent node’s task. (Such a tree is sometimes called a <i>dependency tree</i>.) Which traversal method gives a suitable order in which to do these tasks?</p>
<p class="numlist"><span epub:type="pagebreak" id="page_321"></span>4.&nbsp;&nbsp;Suppose that the tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig9">Figure 5.9</a> models the evolutionary relationships among a set of species of animals, where each node represents a species, and the descendants of a node represent its biological descendants. Which tree traversal method (preorder, postorder, or inorder) gives a possible chronological ordering for when these species could have appeared? Is this ordering unique? Explain.</p>
<p class="numlist">5.&nbsp;&nbsp;Draw and label a single binary tree with six nodes (<i>A</i>, …, <i>F</i>) such that an inorder traversal gives <i>A, B, C, D, E, F</i> and a preorder traversal gives <i>C, B, A, E, D, F</i>.</p>
<p class="numlist">6.&nbsp;&nbsp;Draw and label a binary tree with six nodes (<i>A</i>, …, <i>F</i>) such that an inorder traversal and a postorder traversal both give <i>A, B, C, D, E, F</i>.</p>
<p class="numlist1at">7.&nbsp;&nbsp;(a)&nbsp;&nbsp;Place labels <i>A</i>, …, <i>G</i> in the following tree so that a preorder traversal will visit the nodes in the order <i>A, B, C, D, E, F, G</i>.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig321-1.png" alt="Image" width="533" height="101" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig321-1.png"></p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Do a postorder traversal of the tree in part (a) and list the nodes in the order that they are visited.</p>
<p class="numlist">8.&nbsp;&nbsp;The three tree traversal algorithms (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo5">Algorithms 5.5</a>, <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo6">5.6</a>, and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo7">5.7</a>) can also be regarded as divide-and-conquer algorithms. Explain how the divide-andconquer paradigm applies to these algorithms.</p>
<p class="numlist">9.&nbsp;&nbsp;The solution to <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex7">Example 5.7</a> includes a detailed trace of the preorder traversal algorithm using indentation to show all the recursive calls. Write out a similar trace for (a) the postorder traversal and (b) the inorder traversal of the binary tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig2">Figure 5.2</a>.</p>
<p class="numlistm">10.&nbsp;&nbsp;Let <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>l</sub></i>}, <i>Y</i> = {<i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>m</sub></i>}, and <i>Z</i> = {<i>z</i><sub>1</sub>, <i>z</i><sub>2</sub>, …, <i>z<sub>n</sub></i>} be finite sets. Write an algorithm that traverses the set <i>X</i> × <i>Y</i> × <i>Z</i> using nested <code>for</code>-loops.</p>
<p class="numlistm">11.&nbsp;&nbsp;Refer to <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3def5">Definition 3.5</a> on page 208. Write a traversal algorithm for an SList.</p>
<p class="numlistm">12.&nbsp;&nbsp;Let <i>G</i> be a connected graph in which every vertex has degree 4. Write a recursive traversal algorithm in pseudocode that will visit all the vertices of <i>G</i>, starting at some specified vertex <i>v</i>. Include preconditions and postconditions.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_322"></span>13.&nbsp;&nbsp;Use Prim’s algorithm (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo9">Algorithm 5.9</a>) to construct a minimal spanning tree for the network in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig10">Figure 5.10</a>. What is the total weight of the minimal spanning tree?</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig322-1.png" alt="Image" width="355" height="213" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig322-1.png"></p>
<p class="figcaption"><a id="ch5fig10"></a><b><span class="blue">Figure 5.10</span></b> Network for Exercises 13 and 16b.</p>
</div>
<p class="numlistm">14.&nbsp;&nbsp;Use Prim’s algorithm to construct a minimal spanning tree for the following network. Draw the minimal tree and compute its total weight.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig322-2.png" alt="Image" width="382" height="224" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig322-2.png"></p>
<p class="numlistm">15.&nbsp;&nbsp;Use Prim’s algorithm to construct a minimal spanning tree for the network in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig11">Figure 5.11</a>. What is the total weight of the minimal spanning tree? Is there a unique minimal spanning tree? Explain.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig322-3.png" alt="Image" width="612" height="336" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig322-3.png"></p>
<p class="figcaption"><a id="ch5fig11"></a><b><span class="blue">Figure 5.11</span></b> Network for Exercises 15, 16c, and 17.</p>
</div>
<p class="numlistm"><span epub:type="pagebreak" id="page_323"></span>16.&nbsp;&nbsp;<i>Kruskal’s algorithm</i> gives another way to find a minimal spanning tree in a network.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo13"></a><b>Algorithm 5.13</b> Kruskal’s Algorithm for constructing a minimal spanning tree.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>N</i> is a connected network with <i>n</i> &gt; 2 vertices.</p>
<p class="hang3">Postconditions: <i>T</i> is a minimal spanning tree of <i>N</i>.</p>
<p class="mathet"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq323-1.png" alt="Image" width="177" height="31" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq323-1.png">, <code>where</code> <i>e</i><sub>1</sub> <code>is the shortest edge of</code> <i>N</i>.</p>
<p class="mathe"><code>for</code> <i>i</i> ∈ {2, …, <i>n</i> − 1} <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>e<sub>i</sub></i> ← <code>the shortest edge whose addition to</code> <i>T</i></p>
<p class="mathe2b"><code>will not form a circuit.</code></p>
<p class="mathe2"><span class="mat1">⌞</span> <code>Add edge</code> <i>e<sub>i</sub></i> <code>(and its vertices) to</code> <i>T</i>.</p>
<p class="linetb"></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Is Kruskal’s algorithm greedy? Explain.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Use Kruskal’s algorithm to construct a minimal spanning tree of the network in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig10">Figure 5.10</a>.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Use Kruskal’s algorithm to construct a minimal spanning tree of the network in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig11">Figure 5.11</a>.</p>
<p class="numlistm">17.&nbsp;&nbsp;Sometimes greedy algorithms don’t work at all. Consider the task of finding the shortest path between two nodes in a network. Write a greedy algorithm that inputs a network, a starting point <i>A</i>, and an ending point <i>Z</i>, and attempts to find a shortest path from <i>A</i> to <i>Z</i>. Try your algorithm on the graph in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig11">Figure 5.11</a>. Show that it fails to find the shortest path.</p>
<p class="numlistm">18.&nbsp;&nbsp;Recall that a coloring of a graph is an assignment of colors to the vertices such that no two vertices of the same color are connected by an edge. The following algorithm attempts to produce a coloring for the vertices of a graph <i>G</i> using the fewest number of colors possible.</p>
<p class="mathe2t"><i>C</i> ← <span class="a1">∅</span></p>
<p class="mathe2"><code>while</code> (<i>G</i> <code>has vertices left to color) do</code></p>
<p class="mathe2c"><code>Pick a new color</code> <i>x</i> ∉ <i>C</i>.</p>
<p class="mathe2c"><i>C</i> ← <i>C</i> ∪ {<i>x</i>}</p>
<p class="mathe2c"><code>Assign color</code> <i>x</i> <code>to as many vertices of</code> <i>G</i> <code>as possible, such that no edge connects vertices of the same color.</code></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Which type of algorithm is this?</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Find a graph for which this algorithm fails to produce a coloring with the fewest possible number of colors.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_324"></span>19.&nbsp;&nbsp;Consider the problem of tiling an <i>m</i> × <i>n</i> grid with tiles of the following shapes.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig324-1.png" alt="Image" width="390" height="88" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig324-1.png"></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Show that it is possible to tile a 3 × 4 grid using these tiles.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Show that it is possible to tile a 2 × 4 grid using these tiles.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Explain how a divide-and-conquer algorithm could construct a tiling of a 101 × 100 grid using these tiles.</p>
<p class="numlistm">20.&nbsp;&nbsp;Let <i>T</i> be a binary tree whose nodes are elements of some set <i>U</i>. The following algorithm searches <i>T</i> for a target value <i>t</i> ∈ <i>U</i> and returns true if and only if <i>t</i> is a node in <i>T</i>.</p>
<p class="mathe2t"><code>function Search</code>(<i>t</i> ∈ <i>U, T</i> ∈ {<code>binary trees</code>})</p>
<p class="mathe2b"><code>if</code> <i>T</i> <code>is empty then</code></p>
<p class="mathe2c"><code>return false</code></p>
<p class="mathe2b"><code>else</code></p>
<p class="mathe2c"><code>if</code> <i>t</i> = <code>the root of</code> <i>T</i> <code>then</code></p>
<p class="mathe2d"><code>return true</code></p>
<p class="mathe2c"><code>else</code></p>
<p class="mathe2d"><code>return (Search</code>(<i>t</i>, <code>left subtree of</code> <i>T</i>)</p>
<p class="mathe2e">&nbsp;&nbsp;&nbsp;&nbsp;∨ <code>Search</code>(<i>t</i>, <code>right subtree of</code> <i>T</i><code>))</code></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Write a top-down evaluation of <code>Search</code>(17, <i>T</i>), where <i>T</i> is the tree in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig12">Figure 5.12</a>.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Which type of algorithm is this? Explain.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig324-2.png" alt="Image" width="904" height="159" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig324-2.png"></p>
<p class="figcaptionj"><a id="ch5fig12"></a><b><span class="blue">Figure 5.12</span></b> Binary tree for Exercise 20a. Note that this is <i>not</i> a binary search tree.</p>
</div>
<p class="numlistm">21.&nbsp;&nbsp;Compare the comparisons made by the divide-and-conquer version of <code>FindMax</code> (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo10">Algorithm 5.10</a>) with the comparisons made by the simple <code>for</code>-loop version in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex54">Example 4.54</a>. Use <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <i>x</i><sub>4</sub> = 5,3,2,4.</p>
<p class="numlistm">22.&nbsp;&nbsp;There is a top-down evaluation of <code>MergeSort</code>(12,3,5,17,2,8,9) on page 318. Write this trace in the form of a binary tree, as in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig7">Figure 5.7</a>.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_325"></span>23.&nbsp;&nbsp;Do a trace of <code>MergeSort</code>(23,5,7,13,43,21,17,2) using a top-down evaluation.</p>
<p class="numlistm">24.&nbsp;&nbsp;Write a divide-and-conquer algorithm that computes the sum of all elements of a finite set <i>K</i> = {<i>k</i><sub>1</sub>, <i>k</i><sub>2</sub>, …, <i>k<sub>n</sub></i>} of integers.</p>
<p class="numlist1bt">*25.&nbsp;&nbsp;Write a greedy algorithm that constructs the base two expansion of a given natural number. (Hint: This is like change-making, using coins of denominations 1,2,4,8,16,….)</p>
<p class="h1"><a id="ch5sub3"></a><b>5.3&nbsp;&nbsp;&nbsp;Algorithm Complexity</b></p>
<p class="noindent">In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3sub5">Sections 3.5</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4sub5">4.5</a> we counted the number of operations in some simple algorithms. In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4sub6">Section 4.6</a> we practiced the art of estimating quantities. In this section we will put these two skills together to develop a mathematical way of predicting how fast a given algorithm will work.</p>
<p class="indent">There are many factors that influence how fast a given algorithm will run on a given computer. Technical considerations such as computer architecture, processor speed, and memory access require knowing the current state of affairs in the hardware industry, and this is a moving target. Given all these variables, the most we should expect to get from mathematical analysis of algorithms is a means for making broad comparisons between algorithms. Counting the exact number of operations isn’t so important, but being able to make good estimates is crucial.</p>
<div class="box">
<p class="noindent1"><b>Inquiry 5.6</b> Matheus drives one mile to work along a single road. He never exceeds 30 miles per hour, and there are three stoplights along the way. Matheus can never predict how many lights he will have to stop for, but he knows that each light stays red for 45 seconds before turning green again. What can you say about the time it takes him to complete the trip?</p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.7</b> In three-dimensional computer graphics, the faces of an object are often divided into a triangular mesh, like the boxes below. When an object is rendered to the screen, the program needs to draw only the triangles that would be visible to the viewer. How does the orientation of these boxes determine how many triangles need to be drawn? In general, if a triangular mesh object is composed of <i>n</i> triangular faces, how many triangles would you expect the program to have to draw?</p>
<p class="image-2"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig325-1.png" alt="Image" width="608" height="211" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig325-1.png"></p>
</div>
<div class="box">
<p class="noindent1"><span epub:type="pagebreak" id="page_326"></span><b>Inquiry 5.8</b> Define a function <i>σ</i> : <b>N</b> → <b>N</b> such that <i>σ</i>(<i>n</i>) counts the natural numbers that divide <i>n</i>. For example, <i>σ</i>(6) = 4, because 1, 2, 3, and 6 are the divisors of 6. What can you say about the range of possible values for <i>σ</i>(<i>n</i>)? Consider several different values of <i>n</i>.</p>
</div>
<p class="h2"><a id="ch5sub3sub1"></a><b>5.3.1&nbsp;&nbsp;&nbsp;The Good, the Bad, and the Average</b></p>
<p class="noindent">Often we want to know the answer to the question, “Will Algorithm <i>A</i> finish in time to do <i>X</i>?” Here <i>X</i> could be “finish my report by 5 pm” or “render the next animation frame” or some other constraint on the time of execution. In this situation, a <i>worstcase</i> analysis of the algorithm is useful.</p>
<p class="noindentt"><a id="ch5def4"></a><b>Definition 5.4</b> Let <i>D</i> be the set of all possible inputs of size <i>n</i> for a given algorithm. For <i>d</i> ∈ <i>D</i>, let <i>c</i>(<i>d</i>) be the number of operations performed by the algorithm on data set <i>d</i>. (Note that <i>c</i>(<i>d</i>) depends on <i>n</i> also.) The <i>worst-case</i> number of operations performed by the algorithm is the maximum value of <i>c</i>(<i>d</i>) as <i>d</i> ranges through all elements of <i>D</i>.</p>
<p class="indentt">The <i>time complexity</i> of an algorithm is a measure of how the running time of an algorithm increases as a function of <i>n</i>, the size of the input data. We calculate the worst-case time complexity by calculating the worst-case number of some representative operation in the algorithm. We usually estimate this number using big-<i>O</i> or big-Θ notation.</p>
<p class="noindentt"><a id="ch5ex9"></a><span class="blue"><b>Example 5.9</b></span> Calculate the worst-case time complexity of the sequential search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>).</p>
<p class="noindentt"><i>Solution:</i> Let’s count the number of ≠ comparisons. The <code>while</code>-loop in this algorithm continues to run until the target item <i>t</i> is found, so the worst-case is when <i>t</i> is not in the list. In this case, the algorithm will have to make the ≠ comparison with every element on the list, and finally with the sentinel value. That’s a total of <i>n</i> + 1 comparisons for a list of size <i>n</i>, so the worst-case complexity is Θ(<i>n</i>).</p>
<p class="right">◊</p>
<p class="indentt">How do we know which operation to count? Here we have some latitude. We would like to count the operation that will make the most demands on a computer implementation of the algorithm, but we won’t always be sure what this is. If there is a block of operations that gets repeated more than any other part of the algorithm, it is usually a good idea to count one of the operations in this block. The good news is that most reasonable choices will produce the correct result, especially after passing to big-Θ or big-<i>O</i> notation.</p>
<p class="indent">We will generally strive to report the complexity of an algorithm in big-Θ notation, but there are times when we will have to use big-<i>O</i> instead. It follows immediately from <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4def6">Definitions 4.6</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4def8">4.8</a> that <i>f</i> ∈ <i>O</i>(<i>g</i>) if <i>f</i> ∈ Θ(<i>g</i>). It is also easy to show that if <i>f</i> (<i>n</i>) ≤ <i>g</i>(<i>n</i>) for all <i>n</i>, then <i>f</i> ∈ <i>O</i>(<i>g</i>). (Just take <i>K</i> = 1 in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4def6">Definition 4.6</a>.) <span epub:type="pagebreak" id="page_327"></span>Therefore, if we are forced to overestimate an operation count in a worst-case analysis, we should report our estimate using big-<i>O</i> notation. Just remember that big-<i>O</i> is reporting an upper bound on complexity, not the complexity itself.</p>
<p class="indent">Calculating the complexity of the Euclidean algorithm illustrates this way of using big-<i>O</i> notation. In Exercise 17 of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub1">Section 5.1</a>, we saw a recursive function for finding the greatest common divisor of two natural numbers. Here is an iterative version.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo14"></a><b>Algorithm 5.14</b> The Euclidean Algorithm.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>m, n</i> ∈ {0,1,2,3, …}</p>
<p class="hang3">Postconditions: <i>d</i> is the greatest integer such that <i>d</i> | <i>m</i> and <i>d</i> | <i>n</i>.</p>
<p class="mathet"><i>d</i> ← <i>m</i></p>
<p class="mathe"><i>e</i> ← <i>n</i></p>
<p class="mathe"><code>while</code> <i>e</i> ≠ 0 <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>r</i> ← <i>d</i> mod <i>e</i></p>
<p class="mathe2a"><i>d</i> ← <i>e</i></p>
<p class="mathe2"><span class="mat1">⌞</span> <i>e</i> ← <i>r</i></p>
<p class="linetb"></p>
<p class="noindentt"><a id="ch5ex10"></a><span class="blue"><b>Example 5.10</b></span> Show that the worst-case complexity of the Euclidean algorithm is <i>O</i>(<i>n</i>).</p>
<p class="noindentt"><i>Solution:</i> Like the recursive version, this algorithm makes repeated divisions until the remainder is zero. Let’s try to count the worst-case number of “<i>d</i> mod <i>e</i>” operations in terms of <i>n</i>. The algorithm starts with <i>e</i> equal to <i>n</i>, and each time through the loop, <i>e</i> gets replaced by the remainder <i>r</i> when <i>d</i> is divided by <i>e</i>. To distinguish the old and new values of <i>e</i>, let <i>ê</i> represent the value of <i>e</i> after this replacement, where <i>e</i> is its value before the loop iteration. In this notation,</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq327-2.png" alt="Image" width="162" height="22" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq327-2.png"></p>
<p class="noindent">In particular, this implies that <i>ê</i> &lt; <i>e</i>, since it is the remainder of division by <i>e</i>. So <i>e</i> gets smaller (by at least 1) each time through the loop, and the loop will terminate when <i>e</i> = 0. This shows that the worst-case number of “<i>d</i> mod <i>e</i>” operations is at most <i>n</i>, so the worst-case complexity is <i>O</i>(<i>n</i>).</p>
<p class="right">◊</p>
<p class="indentt">It is important to note that reporting complexity in terms of big-<i>O</i> notation only makes the claim of an upper bound on complexity. The next example shows that the Euclidean algorithm is actually more efficient than <i>O</i>(<i>n</i>).</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_328"></span><a id="ch5ex11"></a><b><span class="blue">Example 5.11</span></b> Show that the worst-case complexity of the Euclidean algorithm is <i>O</i>(log<sub>2</sub> <i>n</i>).</p>
<p class="noindentt"><i>Solution:</i> We’ll improve on the solution to the previous example by showing that <i>e</i> must decrease by at least a factor of 1/2 every two times through the loop; that is, we will show that</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq328-1.png" alt="Image" width="102" height="36" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq328-1.png"></p>
<p class="noindent">We can apply the ^ notation to other variables as well: <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in328-1.png" alt="Image" width="15" height="26" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in328-1.png"> = <i>e</i> expresses the fact that the new value of <i>d</i> is the old value of <i>e</i>. Now consider going through the loop a second time. We then have</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq328-2.png" alt="Image" width="272" height="127" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq328-2.png"></p>
<p class="noindent">If <i>ê</i> ≥ <i>e</i>/2, then <i>ê</i> goes into <i>e</i> once with remainder at most <i>e</i>/2, so</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq328-3.png" alt="Image" width="280" height="35" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq328-3.png"></p>
<p class="noindent">On the other hand, if <i>ê</i> &lt; <i>e</i>/2, then <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in328-2.png" alt="Image" width="11" height="26" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in328-2.png"> &lt; <i>e</i>/2 also, since <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in328-2.png" alt="Image" width="11" height="26" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in328-2.png"> is the remainder of division by <i>ê</i>.</p>
<p class="indent">Therefore the value of <i>e</i> is (at least) halved after two iterations of the loop. Since</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq328-4.png" alt="Image" width="191" height="74" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq328-4.png"></p>
<p class="noindent">it will take at most 1 + 2 log<sub>2</sub> <i>n</i> iterations for the value of <i>e</i> to reach zero. Hence the worst-case complexity is <i>O</i>(log<sub>2</sub> <i>n</i>).</p>
<p class="right">◊</p>
<p class="indentt">In both of the above solutions, we were only able to establish that the number of operations was <i>at most</i> some value; we bounded the number of operations above by a function of <i>n</i>. Since we were unable to get an exact count, and we never established a lower bound, we were forced to report the complexity in big-<i>O</i> notation.</p>
<p class="indent">Worst-case complexity analyses will tell you if your algorithm is good enough, but they won’t always tell you how good it is. We can also calculate <i>best-case</i> complexity, making the obvious modifications to <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5def4">Definition 5.4</a>.</p>
<p class="noindentt"><a id="ch5def5"></a><b>Definition 5.5</b> Let <i>D</i> be the set of all possible inputs of size <i>n</i> for a given algorithm. For <i>d</i> ∈ <i>D</i>, let <i>c</i>(<i>d</i>) be the number of operations performed by the algorithm on data set <i>d</i>. (Note that <i>c</i>(<i>d</i>) depends on <i>n</i> also.) The <i>best-case</i> number of operations performed by the algorithm is the minimum value of <i>c</i>(<i>d</i>) as <i>d</i> ranges through all elements of <i>D</i>.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_329"></span><a id="ch5ex12"></a><b><span class="blue">Example 5.12</span></b> For the sequential search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>), the best-case number of ≠ operations happens when the target <i>t</i> is <i>x</i><sub>1</sub>, the first item in the array. In this case, only one ≠ comparison is made, since the <code>while</code>-loop is never entered. So the best-case complexity is Θ(1).</p>
<p class="indentt">Worst-case and best-case complexity analyses together don’t always tell the whole story, because most data sets in the real world will be somewhere between these two extremes. Actual data tends to fluctuate randomly, and algorithm speed can vary accordingly. The <i>average-case</i> complexity of an algorithm accounts for the range of different possible data sets.</p>
<p class="noindentt"><a id="ch5def6"></a><b>Definition 5.6</b> Suppose that there are <i>k</i> different possible data sets of size <i>n</i> for a given algorithm, and that these different data sets occur randomly. For each <i>i</i> ∈ {1, 2, …, <i>k</i>}, let <i>p<sub>i</sub></i> be the probability that data set <i>i</i> occurs, and let <i>c<sub>i</sub></i> be the number of operations performed by the algorithm on data set <i>i</i>. (Typically, <i>c<sub>i</sub></i> is a function of <i>n</i>.) Then the <i>average-case</i> number of operations performed by the algorithm is</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq329-1.png" alt="Image" width="302" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq329-1.png"></p>
<p class="noindent">In particular, if all the data sets are equally likely, the average-case number of operations is</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq329-2.png" alt="Image" width="216" height="61" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq329-2.png"></p>
<p class="indent">In general, computing the average-case complexity is much trickier than computing the best-case or worst-case complexity. For starters, we have to know more about the set of all possible input data sets, and we have to incorporate this information into our analysis.</p>
<p class="noindentt"><span class="blue"><b>Example 5.13</b></span> Calculate the average-case time complexity of the sequential search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>). Assume that the probability that the target value is in the list is 0.90, and that all list positions are equally likely.</p>
<p class="noindentt"><i>Solution:</i> Notice that if the item is in position <i>i</i>, the algorithm makes <i>i</i> comparisons. Since 90% of the sample space consists of the equally likely list positions 1,2, …, <i>n</i>, each of these has probability 0.9/<i>n</i>. The remaining 10% of the sample space requires <i>n</i>+1 comparisons, by the worst-case analysis. Using <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5def6">Definition 5.6</a>, the average-case number of comparisons is</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq329-3.png" alt="Image" width="893" height="69" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq329-3.png"></p>
<p class="noindent">which simplifies to a linear function of <i>n</i>. So the average-case complexity of the sequential search is Θ(<i>n</i>).</p>
<p class="right">◊</p>
<p class="indent"><span epub:type="pagebreak" id="page_330"></span>In this example, it doesn’t really matter what we assume about the probability of the target being in the list: this number goes away when we pass to big-Θ notation. The next example illustrates another situation in which probabilities can be ignored: some algorithms always do the same amount of work, regardless of the data set.</p>
<p class="noindentt"><span class="blue"><b>Example 5.14</b></span> Recall the bubble sort of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex55">Example 4.55</a>. This algorithm always makes <i>n</i>(<i>n</i>−1)/2 comparisons on a list of <i>n</i> items, no matter what. Therefore the best-case, worst-case, and average-case complexity of the bubble sort is Θ(<i>n</i><sup>2</sup>).</p>
<p class="h2"><a id="ch5sub3sub2"></a><b>5.3.2&nbsp;&nbsp;&nbsp;Approximate Complexity Calculations</b></p>
<p class="noindent">For many important algorithms, counting the number of operations exactly can be tedious, difficult, or impossible. However, judicious use of approximation can help us explore the basic ideas of algorithm complexity without getting too bogged down in the details. The tradeoff is that approximation techniques are not mathematically rigorous, so it is important to treat their results with caution. But understanding rough calculations of complexity will help develop the capacity to think analytically about algorithms.</p>
<p class="noindentt"><span class="blue"><b>Example 5.15</b></span> Approximate the complexity of the iterative binary search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>).</p>
<p class="noindentt"><i>Solution:</i> We have a choice of which operation to count. Since the <code>while</code>-loop is the only part of this algorithm that repeats, it makes sense to count an operation that gets repeated inside this loop. Let’s agree to count the &gt; comparisons on the elements of <i>U</i>. This comparison happens once every time the loop is entered.</p>
<p class="indent">The algorithm works by eliminating <i>approximately</i> half of the items in the list from consideration each time through the loop. The problem is that (<i>l</i> + <i>r</i>)/2 may not be an integer, so <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in330-1.png" alt="Image" width="104" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in330-1.png"> is not exactly in the middle of the list. Sometimes we eliminate a little more than half of the items, sometimes we eliminate a little less. So to say that the list is “halved” at each stage is an approximation.</p>
<p class="indent">At any point in the execution of this algorithm, the number of items under consideration is <i>r</i> − <i>l</i> + 1, and the loop terminates when <i>l</i> = <i>r</i>. In other words, the loop terminates when there is only one item left under consideration. So we can approximate the number of times through the loop by computing the number of times <i>n</i> needs to be halved to obtain 1. Call this number <i>c</i>. Then</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq330-1.png" alt="Image" width="151" height="69" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq330-1.png"></p>
<p class="noindent">so <i>c</i> ≈ log<sub>2</sub> <i>n</i>. We conclude that the complexity of the binary search is approximately Θ(log<sub>2</sub> <i>n</i>). Note that this approximation holds for best-case, worst-case, and average-case, since the number of times through the loop depends only on the size of the list and not on the arrangement of the data set.</p>
<p class="right">◊</p>
<p class="indent"><span epub:type="pagebreak" id="page_331"></span>Our approximation works exactly when <i>n</i> is a power of 2. It is a little tedious to compute this complexity when <i>n</i> is not a power of 2, but you shouldn’t be surprised that the exact calculation shows the complexity of the binary search to be Θ(log<sub>2</sub> <i>n</i>).</p>
<p class="noindentt"><a id="ch5ex16"></a><span class="blue"><b>Example 5.16</b></span> Compute (or approximate) the best- and worst-case complexity of the recursive binary search function (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>).</p>
<p class="noindentt"><i>Solution:</i> Again, let’s agree to count the number of comparisons of elements of <i>U</i>. The best case occurs when the target item is found right away by the very first <code>if</code>-statement. Thus the best-case complexity is Θ(1). For the worst case, approximate the number of comparisons <i>C</i>(<i>n</i>) done on a list of size <i>n</i> by a recurrence relation. If <i>n</i> = 1, the worst our algorithm does is make three comparisons: <i>t</i> <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-3.png" alt="Image" width="20" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-3.png"> <i>x<sub>i</sub>, t</i> <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-1.png" alt="Image" width="18" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-1.png"> <i>x<sub>i</sub></i>, and <i>t</i> <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in307-2.png" alt="Image" width="19" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in307-2.png"> <i>x<sub>i</sub></i>.<sup><a id="rch5fn1" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fn1" class="totri-footnote">1</a></sup> For a list of size <i>n</i>, the algorithm will also make at most three comparisons, followed by a call to <code>BinSearch</code> on a list of approximately half the size. Hence the recurrence relation</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq331-1.png" alt="Image" width="397" height="78" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq331-1.png"></p>
<p class="noindent">gives an approximate measure of the number of comparisons. As long as we are approximating, we might as well make it easy on ourselves by assuming that <i>n</i> = 2<i><sup>p</sup></i> for some <i>p</i>. Let <i>D</i>(<i>p</i>) = <i>C</i>(2<i><sup>p</sup></i>). This related recurrence relation has the following formula:</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq331-2.png" alt="Image" width="427" height="78" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq331-2.png"></p>
<p class="noindent">It is easy to verify the closed-form solution <i>D</i>(<i>p</i>) = 3<i>p</i> + 3. This means that a list of size 2<i><sup>p</sup></i> requires approximately 3<i>p</i> + 3 comparisons, in the worst case. Substituting <i>p</i> = log<sub>2</sub> <i>n</i>, we get that <i>C</i>(<i>n</i>) ≈ 3log<sub>2</sub> <i>n</i> + 3, so we can approximate the worst-case complexity of this algorithm as Θ(log<sub>2</sub> <i>n</i>).</p>
<p class="right">◊</p>
<p class="indentt">The above calculations show that the binary search is more efficient than the sequential search, as far as time complexity is concerned. It is often the case that divide-and-conquer algorithms outperform simpler sequential algorithms. For another example, recall the merge sort.</p>
<p class="noindentt"><span class="blue"><b>Example 5.17</b></span> Approximate the worst-case complexity of the merge sort algorithm.</p>
<p class="noindentt"><i>Solution:</i> First, take another look at the <code>Merge</code> subroutine of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo11">Algorithm 5.11</a>. Its job is to take two ordered arrays <i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>l</sub></i> and <i>z</i><sub>1</sub>, <i>z</i><sub>2</sub>, …, <i>z<sub>m</sub></i> and merge them into one big array <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>, where <i>n</i> = <i>l</i> + <i>m</i>. Think of the data as standing in two lines, arranged by “height,” as in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig13">Figure 5.13</a>. Each time through the loop, the algorithm compares the data elements at the front of each line and chooses the shortest one to become the next element in the list of <i>x<sub>k</sub></i>’s.</p>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_332"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig332-1.png" alt="Image" width="879" height="594" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig332-1.png"></p>
<p class="figcaptionj"><a id="ch5fig13"></a><b><span class="blue">Figure 5.13</span></b> The <code>Merge</code> subroutine combines two ordered arrays. Here <i>y</i><sub>3</sub> &lt; <i>z</i><sub>2</sub>, so <i>y</i><sub>3</sub> is taken to be the next element <i>x</i><sub>4</sub> of the combined array.</p>
</div>
<p class="indent">If we count array item assignments, there are always <i>n</i>, one for each of the <i>x<sub>k</sub></i>’s. However, it is customary to count array-item comparisons instead, and this is a bit more tricky. Once <i>i</i> &gt; <i>l</i>, there are no more items left in the <i>y<sub>i</sub></i> list, so no more array-item comparisons need to be made; in this event the rest of the <i>x<sub>k</sub></i>’s must be taken from the <i>z<sub>j</sub></i> list. Similarly, we run out of <i>z<sub>j</sub></i>’s when <i>j</i> &gt; <i>m</i>, in which case we fill up the rest of the <i>x<sub>k</sub></i>’s using the remaining <i>y<sub>i</sub></i>’s without making any more array-item comparisons. Since one of the lists must run out before the other, there will always be fewer than <i>n</i> comparisons. Things get even more confusing when you take into account that the two lists might not be exactly the same size (when <i>l</i> ≠ <i>m</i>), so determining an exact count of the operations in the <code>Merge</code> algorithm is hard. Let’s just say that this subroutine requires <i>n</i> operations, and remember that we are making a conservative overestimate.</p>
<p class="indent">Now consider the recursive <code>MergeSort</code> function (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo12">Algorithm 5.12</a>). To make the calculation easier, assume the size of our array is <i>n</i> = 2<i><sup>p</sup></i>. A merge sort on a list of 2<i><sup>p</sup></i> elements performs a <code>Merge</code> on a 2<i><sup>p</sup></i>-element list after performing two merge sorts on lists of size 2<sup><i>p</i>−1</sup>. Therefore, by the addition principle for algorithms, we have the following recurrence relation for <i>C</i>(<i>p</i>), the approximate number of comparison operations done on a list of size 2<i><sup>p</sup></i>:</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq332-1.png" alt="Image" width="454" height="78" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq332-1.png"></p>
<p class="noindent"><span epub:type="pagebreak" id="page_333"></span>It is left as an exercise to show that <i>C</i>(<i>p</i>) = <i>p</i> · 2<i><sup>p</sup></i> is the closed-form solution. Therefore, a list of 2<i><sup>p</sup></i> items requires at most <i>p</i> · 2<i><sup>p</sup></i> comparisons in the worst case. Substituting <i>p</i> = log<sub>2</sub> <i>n</i>, this says that a <code>MergeSort</code> on list of <i>n</i> items requires approximately</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq333-1.png" alt="Image" width="356" height="82" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq333-1.png"></p>
<p class="noindent">comparisons.<sup><a id="rch5fn2" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fn2" class="totri-footnote">2</a></sup> We are using big-<i>O</i> here instead of big-Θ because we overestimated the number of comparisons done by the <code>Merge</code> subroutine. In the next section, we will see that <i>every</i> sorting algorithm must have complexity at least Θ(<i>n</i> log<sub>2</sub> <i>n</i>). This fact, combined with the above result, implies that the merge sort has complexity Θ(<i>n</i> log<sub>2</sub> <i>n</i>).</p>
<p class="right">◊</p>
<p class="border"></p>
<p class="border1"></p>
<p class="h3"><a id="ch5exe3"></a>Exercises 5.3</p>
<p class="numlist">1.&nbsp;&nbsp;Look back at <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex12">Example 5.12</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>. Count the best- and worst-case number of assignment statements involving items of the array. In other words, count the number of times the statement</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq333-2.png" alt="Image" width="113" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq333-2.png"></p>
<p class="numlistpara1">is executed. Why is this statement a bad choice for calculating the complexity of this algorithm?</p>
<p class="numlist">2.&nbsp;&nbsp;Step through <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo14">Algorithm 5.14</a> using <i>m</i> = 42 and <i>n</i> = 24. Compare this trace with the result of Exercise 17 of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub1">Section 5.1</a>.</p>
<p class="numlist">3.&nbsp;&nbsp;Explain why the results of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex10">Example 5.10</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex11">Example 5.11</a> do not contradict each other.</p>
<p class="numlist">4.&nbsp;&nbsp;Which statement is stronger: “this algorithm has complexity Θ(<i>n</i><sup>3</sup>)” or “this algorithm has complexity <i>O</i>(<i>n</i><sup>3</sup>)”? Explain.</p>
<p class="numlist">5.&nbsp;&nbsp;Consider <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo8">Algorithm 5.8</a> for making change. Let 1 ≤ <i>N</i> ≤ 100.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;What is the best-case number of ≥ comparisons? For what <i>N</i> does this occur? Justify your answer.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;What is the worst-case number of ≥ comparisons? For what <i>N</i> does this occur? Justify your answer.</p>
<p class="numlist"><span epub:type="pagebreak" id="page_334"></span>6.&nbsp;&nbsp;Consider <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo8">Algorithm 5.8</a> for making change. Suppose <i>N</i> ∈ {10,15,20,25}, and all these values are equally likely. Compute the average-case number of ≥ comparisons. (Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5def6">Definition 5.6</a>.)</p>
<p class="numlist">7.&nbsp;&nbsp;Consider the following algorithm.</p>
<p class="mathe2t"><i>i</i> ← 2</p>
<p class="mathe2"><code>while</code> (<i>N</i> mod <i>i</i>) ≠ 0 <code>do</code></p>
<p class="mathe2c"><i>i</i> ← <i>i</i> + 1</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Suppose that <i>N</i> ∈ {2,3,4,5,…,100}. Find the best- and worst-case number of “<i>N</i> mod <i>i</i>” operations made by this algorithm.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Suppose instead that <i>N</i> ∈ {2,3,4,5,6,7,8}, and all these values are equally likely. Find the average-case number of “<i>N</i> mod <i>i</i>” operations made by this algorithm.</p>
<p class="numlist">8.&nbsp;&nbsp;Find the (a) best-case, (b) worst-case, and (c) average-case number of &lt; comparisons performed by the following pseudocode segment. For parts (a) and (b), tell which values of <i>n</i> produce the best and worst cases. For part (c), assume that all possible values of <i>n</i> are equally likely.</p>
<p class="numlistparah">Preconditions: <i>n</i> ∈ {5,10,15,20,25}.</p>
<p class="mathe2t"><code>while</code> <i>n</i> &lt; 17 <code>do</code></p>
<p class="mathe2b"><i>n</i> ← <i>n</i> + 5</p>
<p class="numlist">9.&nbsp;&nbsp;Count the (a) best-case, (b) worst-case, and (c) average-case number of + operations performed by the following pseudocode segment. Assume that all possible data sets are equally likely.</p>
<p class="numlistparah">Preconditions: <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, <i>x</i><sub>4</sub>, <i>x</i><sub>5</sub>} ⊆ {10,20,30,40,50,60}, where <i>x</i><sub>1</sub> &lt; <i>x</i><sub>2</sub> &lt; <i>x</i><sub>3</sub> &lt; <i>x</i><sub>4</sub> &lt; <i>x</i><sub>5</sub>.</p>
<p class="mathe2t"><i>t</i> ← 0</p>
<p class="mathe2"><i>i</i> ← 1</p>
<p class="mathe2"><code>while</code> <i>t</i> &lt; 101 <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>t</i> ← <i>t</i> + <i>x<sub>i</sub></i></p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="numlistm">10.&nbsp;&nbsp;Find the (a) best-case, (b) worst-case, and (c) average-case number of &lt; comparisons performed by the following pseudocode segment. For parts (a) and (b), tell which data sets produce the best and worst cases. For part (c), assume that all possible data sets are equally likely.</p>
<p class="numlistparah"><span epub:type="pagebreak" id="page_335"></span>Preconditions: <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>} ⊆ {5,10,15,20,25} and <i>x</i><sub>1</sub> &lt; <i>x</i><sub>2</sub> &lt; <i>x</i><sub>3</sub>.</p>
<p class="mathe2t"><i>i</i> ← 1</p>
<p class="mathe2"><code>while</code> <i>x<sub>i</sub></i> &lt; 12 <code>do</code></p>
<p class="mathe2b">&nbsp;<i>i</i> ← <i>i</i> + 1</p>
<p class="numlistm">11.&nbsp;&nbsp;In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex54">Example 4.54</a> we observed that the following algorithm performs <i>n</i> − 1 “<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in122-2.png" alt="Image" width="18" height="15" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in122-2.png">” comparisons.</p>
<p class="mathe2t"><i>m</i> ← <i>x</i><sub>1</sub></p>
<p class="mathe2"><code>for</code> <i>i</i> ∈ {2,3, …, <i>n</i>} <code>do</code></p>
<p class="mathe2b"><code>if</code> <i>m</i> ≺ <i>x<sub>i</sub></i> <code>then</code> <i>m</i> ← <i>x<sub>i</sub></i></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Find the best-case number of “←” operations.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Find the worst-case number of “←” operations.</p>
<p class="numlistm">12.&nbsp;&nbsp;The bubble sort that we introduced in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex55">Example 4.55</a> is sometimes called the “dumb” bubble sort because it will continue to run even after the array has been put in order. The following algorithm checks a true/false variable <i>s</i> each time through the loop to see if any more sorting is necessary.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo15"></a><b>Algorithm 5.15</b> The Smart Bubble Sort.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> ∈ <i>U</i>, a set that is totally ordered by &lt;, and <i>n</i> ≥ 2.</p>
<p class="hang3">Postconditions: <i>x</i><sub>1</sub> ≤ <i>x</i><sub>2</sub> ≤ ··· ≤ <i>x<sub>n</sub></i>.</p>
<p class="mathet"><i>s</i> ← <code>false //</code> <i>s</i> = <code>"array is sorted"</code></p>
<p class="mathe"><i>i</i> ← 1</p>
<p class="mathe"><code>while</code> ¬<i>s</i> <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>j</i> ← 1</p>
<p class="mathe2a"><i>s</i> ← <code>true</code> <code>// array is sorted UNLESS …</code></p>
<p class="mathe2a"><code>while</code> <i>j</i> ≤ <i>n − i</i> <code>do</code></p>
<p class="mathe2c"><span class="mat1">⌜</span> <code>if</code> <i>x</i><sub><i>j</i></sub> &gt; <i>x</i><sub><i>j</i>+1</sub> <code>then</code></p>
<p class="mathe2d"><span class="mat1">⌜</span> <code>swap</code> <i>x<sub>j</sub></i> <code>and</code> <i>x</i><sub><i>j</i>+1</sub></p>
<p class="mathe2d"><span class="mat1">⌞</span><i>s</i> ← <code>false // … a swap is made</code></p>
<p class="mathe2c"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="linetb"></p>
<p class="numlistpara1">This algorithm takes advantage of the observation that if no swaps are made, then the array must be in order.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Trace through this algorithm for the array <i>x</i><sub>1</sub> = 1, <i>x</i><sub>2</sub> = 7, <i>x</i><sub>3</sub> = 4, <i>x</i><sub>4</sub> = 9.</p>
<p class="loweralpha1"><span epub:type="pagebreak" id="page_336"></span>(b)&nbsp;&nbsp;What is the best-case number of array item comparisons in this algorithm, in terms of <i>n</i>? For what kind of data sets does it occur?</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;What is the worst-case number of array item comparisons in this algorithm, in terms of <i>n</i>? For what kind of data sets does it occur?</p>
<p class="numlistm">13.&nbsp;&nbsp;Suppose that two arrays <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> and <i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, …, <i>y<sub>n</sub></i> have at least one element in common. The following algorithm finds <i>i, j</i> such that <i>x<sub>i</sub></i> = <i>y<sub>j</sub></i>. Compute its best-case and worst-case complexity. (Count the number of ≠ comparisons.)</p>
<p class="mathe2t"><i>i</i> ← 0</p>
<p class="mathe2"><i>j</i> ← <i>n</i> + 1</p>
<p class="mathe2"><code>while</code> <i>j</i> = <i>n</i> + 1 <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2c"><i>y</i><sub><i>n</i>+1</sub> ← <i>x<sub>i</sub></i></p>
<p class="mathe2c"><i>j</i> ←1</p>
<p class="mathe2c"><code>while</code> <i>x<sub>i</sub></i> ≠ <i>y<sub>j</sub></i> <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌞</span>&nbsp;&nbsp;&nbsp;&nbsp;<i>j</i> ← <i>j</i> + 1</p>
<p class="numlistm">14.&nbsp;&nbsp;Consider the following way of sorting an array <i>X</i> with <i>n</i> elements.</p>
<p class="loweralpha1-le"><code>Put the elements of <i>X</i> into a binary search tree. Do an inorder traversal of your tree.</code></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Approximate the average-case complexity of this algorithm. (For the average case, assume that you get a balanced binary search tree. Don’t bother with <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5def6">Definition 5.6</a>.)</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Compute the worst-case complexity of this algorithm. (Hint: The worst case occurs when the array is in order to begin with!)</p>
<p class="numlistm">15.&nbsp;&nbsp;The following algorithm can be applied to a weighted, directed graph with starting nodes {<i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub>, <i>A</i><sub>4</sub>} and ending nodes {<i>B</i><sub>1</sub>, <i>B</i><sub>2</sub>, <i>B</i><sub>3</sub>, <i>B</i><sub>4</sub>}. It finds a directed path starting at some starting node <i>A</i> and ending at some <i>B<sub>i</sub></i>, and it computes <i>w</i>, the total weight of the path.</p>
<p class="mathet"><i>w</i> ← 0</p>
<p class="mathe"><code>while</code> <i>A</i> ∉ {<i>B</i><sub>1</sub>, <i>B</i><sub>2</sub>, <i>B</i><sub>3</sub>, <i>B</i><sub>4</sub>} <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>e</i> ← <code>the shortest edge starting at</code> <i>A</i></p>
<p class="mathe2a"><i>w</i> ← <i>w</i> + <code>the weight of</code> <i>e</i></p>
<p class="mathe2"><span class="mat1">⌞</span> <i>A</i> ← <code>the vertex</code> <i>e</i> <code>points to</code></p>
<p class="numlistpara1">For example, when applied to the following graph, if <i>A</i> = <i>A</i><sub>2</sub> initially, the algorithm follows the edges labeled 3, 1, and 1, and computes <i>w</i> = 3 + 1 + 1 = 5.</p>
<p class="image"><span epub:type="pagebreak" id="page_337"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig337-1.png" alt="Image" width="614" height="445" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig337-1.png"></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Which kind of algorithm is this (traversal, greedy, or divide-and-conquer)? Explain.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Compute the average-case value of <i>w</i> over the possible inputs <i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub>, <i>A</i><sub>4</sub>. Assume that each of these inputs is equally likely.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Does the algorithm always succeed in finding the shortest directed path from <i>A</i> to some <i>B<sub>i</sub></i>? Why or why not?</p>
<p class="numlistm">16.&nbsp;&nbsp;In this problem we will approximate the complexity of Prim’s algorithm for finding a minimal spanning tree of a network <i>N</i> (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo9">Algorithm 5.9</a>). Let the input size <i>n</i> be the number of vertices in <i>N</i>.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Suppose that no vertex has degree greater than 5. Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/08_Chapter02.xhtml#ch2the6">Theorem 2.6</a> to explain why the number of edges is at most a linear function of <i>n</i>.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex54">Example 4.54</a> to approximate the worst-case number of comparisons needed for the following part of the algorithm.</p>
<p class="loweralpha1_c5"><i>e</i> ←&nbsp;<code>the shortest edge between a vertex in</code> <i>T</i> <code>and a vertex not in</code> <i>T</i>.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Give an approximate big-<i>O</i> estimate for the worst-case complexity of Prim’s algorithm.</p>
<p class="numlistm">17.&nbsp;&nbsp;Use a recurrence relation to approximate the number of comparisons done by the recursive <code>FindMax</code> function (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo10">Algorithm 5.10</a>).</p>
<p class="numlistm">18.&nbsp;&nbsp;Consider the following algorithm for finding a target element <i>t</i> in an array <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>. Assume as a precondition that exactly one of the <i>x<sub>i</sub></i>’s is equal to <i>t</i>.</p>
<p class="mathe2t"><code>Choose</code> <i>i</i> <code>at random from</code> {1,2, …, <i>n</i>}.</p>
<p class="mathe2"><code>while</code> <i>x<sub>i</sub></i> ≠ <i>t</i> <code>do</code></p>
<p class="mathe2b"><code>Choose</code> <i>i</i> <code>at random from</code> {1,2, …, <i>n</i>}.</p>
<p class="mathe2"><code>print</code> Element <i>t</i> was found in location <i>i</i>.</p>
<p class="numlistpara1"><span epub:type="pagebreak" id="page_338"></span>This algorithm continues to guess randomly until it finds where <i>t</i> is. Note that it does not keep track of its previous guesses, so it may check the same location more than once.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Find the best-case number of ≠ comparisons made by this algorithm.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;<i>Warning: Tricky</i>. Find the worst-case number of ≠ comparisons made by this algorithm.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;<i>Calculus required</i>. Use the sum of an infinite series to find the averagecase number of ≠ comparisons made by this algorithm.</p>
<p class="numlistm">19.&nbsp;&nbsp;Use induction to prove that the recurrence relation</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq338-1.png" alt="Image" width="422" height="78" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq338-1.png"></p>
<p class="numlistpara1">has the closed-form solution <i>C</i>(<i>i</i>) = <i>i</i> · 2<i><sup>i</sup></i>.</p>
<p class="numlistm">20.&nbsp;&nbsp;The concept of best-, worst-, and average-case analyses extends beyond algorithms to other counting problems in mathematics. Recall that the height of a binary tree is the number of edges in the longest path from the root to a leaf.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Find the best-case height of a binary tree with five nodes.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Find the worst-case height of a binary tree with five nodes.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Find the average-case height of a binary tree with five nodes. For this problem, you will have to list all possible binary trees with five nodes. Assume that each of these is equally likely to occur.</p>
<p class="loweralpha1">(d)&nbsp;&nbsp;Find the worst-case height of a binary tree with <i>n</i> nodes.</p>
<p class="loweralpha1">(e)&nbsp;&nbsp;Approximate the best-case height of a binary tree with <i>n</i> nodes.</p>
<p class="numlistm">21.&nbsp;&nbsp;Suppose you have 100 square tiles, each measuring 1 foot by 1 foot. These tiles can be arranged in the shape of a solid rectangle in five different (i.e., noncongruent) ways.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Find the best-case (i.e., smallest) perimeter of such a rectangle.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Find the worst-case perimeter of such a rectangle.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Find the average-case perimeter of such a rectangle, assuming that the five cases are equally likely to occur.</p>
<p class="numlistm">22.&nbsp;&nbsp;Find the best-, worst-, and average-case values for rolling two standard six-sided dice. (Hint: Refer to <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4ex36">Example 4.36</a>.)</p>
<p class="numlistm">23.&nbsp;&nbsp;An urn contains three red marbles and two green marbles. Four marbles are drawn at random from the urn. Find the best-, worst-, and average-case number of red marbles in this random drawing. (In probability, the average-case number of red marbles is called the <i>expected value</i>.)</p>
<p class="h1"><a id="ch5sub4"></a><span epub:type="pagebreak" id="page_339"></span><b>5.4&nbsp;&nbsp;&nbsp;Bounds on Complexity</b></p>
<p class="noindent">So far our study of complexity has centered on counting or estimating the number of operations a given algorithm performs. In this section we take a different point of view: given a task (e.g., sorting a list), what is the best we can expect <i>any</i> algorithm to do? More specifically, given sets of preconditions and postconditions, what is a lower bound on the worst-case complexity of an algorithm that satisfies those preconditions and postconditions?</p>
<p class="indent">This question is much harder, in general, than the question of how a specific algorithm will perform. To answer it, we must focus on the intrinsic difficulty of the given algorithmic task, not on the algorithm. This kind of question belongs to the study of <i>computational complexity</i>. While most of the techniques in computational complexity theory are beyond the scope of this book, this section presents some relatively simple examples that are now within our grasp.</p>
<div class="box">
<p class="noindent1"><b>Inquiry 5.9</b> There are many ways to design a tournament. A fair tournament gives every participant an equal chance to win the tournament and guarantees that there will be a clear winner. What is the minimum number of games that need to be played in a fair tournament with 16 players? Why can’t you have a fair tournament with fewer games?</p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.10</b> Design a fair tournament for four players that establishes a clear first-place winner and also a clear second-place winner. What is the fewest number of games that need to be played?</p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.11</b> There are many different Euler circuits in the following graph. Find one. Notice that at each degree-four vertex, you have the option of continuing your path straight through the vertex or turning one way or the other. Can you minimize the number of “turns” your circuit makes? How can you tell if you have found the circuit with the fewest number of turns?</p>
<p class="image-2"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig339-1.png" alt="Image" width="196" height="195" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig339-1.png"></p>
</div>
<p class="h2"><a id="ch5sub4sub1"></a><b>5.4.1&nbsp;&nbsp;&nbsp;Algorithms as Decisions</b></p>
<p class="noindent">Sometimes we can think of an algorithm as a sequence of decisions. A program accepts some input values and then, through a sequence of mathematical operations, decides on some output values. If we understand the types of decisions necessary to solve a problem, we can determine—in some cases—whether an algorithm is working as efficiently as possible.</p>
<p class="indent"><span epub:type="pagebreak" id="page_340"></span>To illustrate this idea, consider the problem of identifying a particular species of bird. Suppose we are given an unknown bird <i>B</i> to identify, and for simplicity assume that we know that <i>B</i> must belong to one of four species: Steller’s Jay, Western Scrub Jay, California Thrasher, and California Towhee. We are given the following facts about these species.</p>
<table class="table">
<tbody><tr>
<td class="left" style="width:40%;"><span class="blue">Species</span></td>
<td class="left1" style="width:60%;"><span class="blue">Facts</span></td>
</tr>
<tr>
<td class="centerlbt"></td>
<td class="center1t"></td>
</tr>
<tr>
<td class="centerlb-r">Steller’s Jay</td>
<td class="left1">Mostly blue, with a black crest.</td>
</tr>
<tr>
<td class="centerlb-r">Western Scrub Jay</td>
<td class="left1">Mostly blue, without a crest.</td>
</tr>
<tr>
<td class="centerlb-r">California Thrasher</td>
<td class="left1">Mostly brown, with a curved bill.</td>
</tr>
<tr>
<td class="centerlb-rs">California Towhee</td>
<td class="left1s">Mostly brown, with a conical bill.</td>
</tr>
</tbody></table>
<p class="noindent">The following two algorithms present two ways to identify the bird <i>B</i>.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo16"></a><b>Algorithm 5.16</b> Identifying a bird <i>B</i>.</p>
<p class="lineb"></p>
<p class="mathet"><code>if</code> <i>B</i> <code>has a crest then</code></p>
<p class="mathe1"><code>print</code> <i>B</i> is a Steller’s Jay.</p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><code>if</code> <i>B</i> <code>is mostly blue then</code></p>
<p class="mathe2"><code>print</code> <i>B</i> is a Western Scrub Jay.</p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><code>if</code> <i>B</i> <code>has a curved bill then</code></p>
<p class="mathe2a"><code>print</code> <i>B</i> is a California Thrasher.</p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><code>print</code> <i>B</i> is a California Towhee.</p>
<p class="linetb"></p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo17"></a><b>Algorithm 5.17</b> Identifying a bird <i>B</i>.</p>
<p class="lineb"></p>
<p class="mathet"><code>if</code> <i>B</i> <code>is mostly blue then</code></p>
<p class="mathe1"><span class="mat1">⌜</span> <code>if</code> <i>B</i> <code>has a crest then</code></p>
<p class="mathe2a"><code>print</code> <i>B</i> is a Steller’s Jay.</p>
<p class="mathe2"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌞</span>&nbsp;&nbsp;<code>print</code> <i>B</i> is a Western Scrub Jay.</p>
<p class="mathe1"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌜</span> <code>if</code> <i>B</i> <code>has a curved bill then</code></p>
<p class="mathe2a"><code>print</code> <i>B</i> is a California Thrasher.</p>
<p class="mathe2"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌞</span>&nbsp;&nbsp;<code>print</code> <i>B</i> is a California Towhee.</p>
<p class="linetb"></p>
<p class="indent">Both of these algorithms identify the bird through a sequence of “yes or no” questions; these are decisions with two possible outcomes. However, they do so in slightly different ways. To compare these algorithms, consider the decision trees in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig14">Figure 5.14</a>.</p>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_341"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig341-1.png" alt="Image" width="1008" height="306" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig341-1.png"></p>
<p class="figcaption"><a id="ch5fig14"></a><b><span class="blue">Figure 5.14</span></b> Decision-tree models for Algorithms 5.16 (left) and 5.17 (right).</p>
</div>
<p class="indent">Both decision trees have four leaves; these correspond to the four different possible outcomes of the algorithm: bird <i>B</i> belongs to one of the four species. However, the height of the tree for <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo16">Algorithm 5.16</a> is greater than the height of the tree for <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">Algorithm 5.17</a>, so <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo16">Algorithm 5.16</a> may have to answer more questions to correctly identify the bird. The worst-case number of questions answered by <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo16">Algorithm 5.16</a> is three, while <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">Algorithm 5.17</a> needs to answer at most two.</p>
<p class="indent">If we measure efficiency by the worst-case number of questions answered, then <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">Algorithm 5.17</a> is more efficient. But we can say more. The decision-tree analysis shows that <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">Algorithm 5.17</a> is the <i>most</i> efficient possible algorithm for solving this problem, because its decision tree has the smallest possible height. Any algorithm that answers “yes or no” questions can be modeled with a binary tree, as in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig14">Figure 5.14</a>. Since identifying <i>B</i> requires distinguishing among four possible outcomes, such a tree must have (at least) four leaves. The tree for <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">Algorithm 5.17</a> is the shortest possible binary tree with four leaves; you can’t do any better.</p>
<p class="noindentt"><a id="ch5def7"></a><b>Definition 5.7</b> An algorithm that, in the worst case, solves a given problem using the fewest possible operations of a given type is called <i>optimal</i>.</p>
<p class="indentt"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">Algorithm 5.17</a> is an optimal solution to our (contrived) bird identification problem with respect to the number of “yes or no” question operations. In general, proving the optimality of an algorithm is very difficult, but the following examples explore some cases for which we have the necessary tools.</p>
<p class="noindentt"><a id="ch5ex18"></a><span class="blue"><b>Example 5.18</b></span> Consider the problem of identifying a counterfeit coin from among a set of 10 coins using only a balance scale. Suppose that all the genuine coins weigh the same, but the counterfeit coin weighs slightly less than the real coins. How many weighings are needed to identify the fake?</p>
<p class="noindentt"><i>Solution:</i> The balance scale is an operation with three possible outcomes: it could tilt left, tilt right, or balance evenly. We could attempt a divide-and-conquer algorithm for finding the counterfeit coin: divide the coins in half and weigh them. The lighter group contains the fake coin. Repeat until you find the coin. If you ever have to weigh an odd number of coins, keep one coin apart and weigh the rest; if the balance stays level, the separate coin is the fake.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig342-1.png" alt="Image" width="914" height="329" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig342-1.png"></p>
<p class="figcaption"><a id="ch5fig15"></a><b><span class="blue">Figure 5.15</span></b> Decision tree for finding a counterfeit coin.</p>
</div>
<p class="indent"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig15">Figure 5.15</a> illustrates this process. The left branch represents the event that the left side is lighter, the right branch represents the right being lighter, and the middle branch represents the two sides balancing. Note that this method requires three weighings, worst case.</p>
<p class="indent"><span epub:type="pagebreak" id="page_342"></span>This divide-and-conquer approach isn’t the only way to do the problem. For example, we could have begun by setting two or more coins apart, in hope of finding the coin faster. Since there are lots of other ways to do this task, we should wonder whether it is possible to identify the coin in fewer than three weighings. But any scheme we devise must produce a decision tree with 10 leaves, because there are 10 choices for the counterfeit coin.</p>
<p class="indent">Since weighing on a balance scale is a 3-ary (or <i>ternary</i>) operation, a sequence of two weighings can produce a tree with at most nine leaves. Therefore, no matter how clever we are, there is no way to distinguish between 10 different outcomes using only two weighings. Thus the solution outlined in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig15">Figure 5.15</a> using three weighings is optimal.</p>
<p class="right">◊</p>
<p class="h2"><a id="ch5sub4sub2"></a><b>5.4.2&nbsp;&nbsp;&nbsp;A Lower Bound</b></p>
<p class="noindent">In both the bird identification and counterfeit coin examples, we needed to know the maximum number of leaves possible in a decision tree. The number of children of each node equals the number of possible options for each decision; a decision tree where each decision has <i>m</i> options produces an <i>m</i>-ary tree. A standard induction argument will establish the following observation.</p>
<p class="noindentt"><a id="ch5lem1"></a><span epub:type="pagebreak" id="page_343"></span><b>Lemma 5.1</b> Let <i>m</i> ≥ 2 and <i>p</i> ≥ 0 be integers. An <i>m</i>-ary tree with height <i>p</i> has at most <i>m<sup>p</sup></i> leaves.<sup><a id="rch5fn3" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fn3" class="totri-footnote">3</a></sup></p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;Exercise. (Use induction on <i>p</i>.)</p>
<p class="right">□</p>
<p class="indentt">In other words, a sequence of <i>p</i> decisions, each of which has <i>m</i> choices, can produce at most <i>m<sup>p</sup></i> different outcomes. We used this lemma implicitly in the above solutions. The following theorem describes our technique more generally.</p>
<p class="noindentt"><a id="ch5the1"></a><b>Theorem 5.1</b> <i>Let <i>n</i> measure the size of the input for a certain task, and suppose that any algorithm that solves this task must distinguish between f</i> (<i>n</i>) <i>different possibilities. If an algorithm is based on an operation X that has m different outcomes, then the worst-case number of X operations this algorithm performs must be at least</i> log<i><sub>m</sub></i>(<i>f</i> (<i>n</i>)).</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;The work of the algorithm can be modeled in terms of an <i>m</i>-ary decision tree: every time the algorithm performs operation <i>X</i>, it makes a decision among <i>m</i> choices. Since there are <i>f</i> (<i>n</i>) possible outcomes, the algorithm must perform enough <i>X</i> operations so that this tree has at least <i>f</i> (<i>n</i>) leaves. Let <i>p</i> be the worst-case number of times operation <i>X</i> is performed, so the decision tree has height <i>p</i>. By <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5lem1">Lemma 5.1</a>, the decision tree has at most <i>m<sup>p</sup></i> leaves. Therefore, <i>f</i> (<i>n</i>) ≤ <i>m<sup>p</sup></i>, so log<i><sub>m</sub></i>(<i>f</i> (<i>n</i>)) ≤ <i>p</i>.</p>
<p class="right1">□</p>
<p class="indentt">This theorem tends to give a very conservative lower bound; in most cases an algorithm will perform many more operations than the theorem guarantees. However, for two important examples—searching and sorting—we have already seen algorithms that are as efficient as possible, in the sense that their worst-case complexity is in the same Θ-class as the lower bound given by <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a>.</p>
<p class="noindentt"><a id="ch5def8"></a><b>Definition 5.8</b> Suppose that the worst-case number of operations of a given type needed to solve a given problem is at least <i>w</i>(<i>n</i>). An algorithm is called <i>asymptotically optimal</i> if the number of operations it uses to solve the problem is in Θ(<i>w</i>(<i>n</i>)).</p>
<p class="indentt">In other words, an asymptotically optimal algorithm is optimal up to a big-Θ estimate.</p>
<p class="h2"><a id="ch5sub4sub3"></a><b>5.4.3&nbsp;&nbsp;&nbsp;Searching an Array</b></p>
<p class="noindent">Recall the two algorithms for searching an array: the sequential search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>) and the binary search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>). Both of these algorithms were <span epub:type="pagebreak" id="page_344"></span>based on <i>binary</i> comparisons, that is, operations having two different outcomes. In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex9">Example 5.9</a>, we counted the ≠ operations to show that the worst-case complexity of the sequential search is Θ(<i>n</i>). <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex16">Example 5.16</a> analyzed the &lt; operation to estimate the complexity of the binary search at Θ(log<sub>2</sub> <i>n</i>). The next theorem says that you can’t do better than a binary search.</p>
<p class="noindentt"><b>Proposition 5.1</b> Any algorithm that uses binary comparisons to search an array of size <i>n</i> for a target element must require at least <i>w</i>(<i>n</i>) ∈ Θ(log<sub>2</sub> <i>n</i>) comparisons, in the worst case.</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;A searching algorithm must be able to distinguish between <i>n</i>+1 possibilities: the target element could be in any of the positions 1,2, …, <i>n</i>, or it could fail to be in the list. <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> tells us that the worst-case number of comparisons must be at least log<sub>2</sub>(<i>n</i> + 1), which is in Θ(log<sub>2</sub> <i>n</i>).</p>
<p class="right">□</p>
<p class="indentt">Since the binary search has worst-case complexity Θ(log<sub>2</sub> <i>n</i>), it achieves the lower bound set by Proposition 5.1. In other words, the binary search is an asymptotically optimal solution to the searching problem, with respect to the number of comparisons.</p>
<p class="h2"><a id="ch5sub4sub4"></a><b>5.4.4&nbsp;&nbsp;&nbsp;Sorting</b></p>
<p class="noindent">The key to viewing sorting an array as a decision problem is to see it as choosing a correct arrangement from among all the possible arrangements of data. A sorting algorithm must rearrange the data, and there is only one way to put the list in order. Since there are <i>n</i>! different ways to arrange an array of <i>n</i> elements, we have the following result.</p>
<p class="noindentt"><b>Proposition 5.2</b> Any sorting algorithm based on binary comparisons must perform at least <i>w</i>(<i>n</i>) ∈ Θ(<i>n</i>log<sub>2</sub> <i>n</i>) comparisons in the worst case to sort an array of <i>n</i> elements.</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;By the above discussion, <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> shows that a sorting algorithm must perform at least log<sub>2</sub>(<i>n</i>!) comparisons to sort a list of <i>n</i> elements, worst case. Since</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq344-1.png" alt="Image" width="490" height="159" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq344-1.png"></p>
<p class="noindent"><span epub:type="pagebreak" id="page_345"></span>we have log<sub>2</sub>(<i>n</i>!) ∈ <i>O</i>(<i>n</i>log<sub>2</sub> <i>n</i>). Since</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq345-1.png" alt="Image" width="752" height="186" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq345-1.png"></p>
<p class="noindent">and, since log<sub>2</sub>(<i>n</i>!)<sup>2</sup> = 2 log<sub>2</sub>(<i>n</i>!), it follows that</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq345-2.png" alt="Image" width="433" height="62" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq345-2.png"></p>
<p class="noindent">so log<sub>2</sub>(<i>n</i>!) = Ω(<i>n</i> log<sub>2</sub> <i>n</i>). By <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml#ch4def8">Definition 4.8</a>, we have shown that log<sub>2</sub>(<i>n</i>!) ∈ Θ(<i>n</i> log<sub>2</sub> <i>n</i>), as required.</p>
<p class="right1">□</p>
<p class="indentt">We have already seen an asymptotically optimal sorting algorithm: the merge sort has worst-case complexity Θ(<i>n</i>log<sub>2</sub> <i>n</i>).</p>
<p class="h2"><a id="ch5sub4sub5"></a><b>5.4.5&nbsp;&nbsp;&nbsp;<i>P</i> vs. <i>NP</i></b></p>
<p class="noindent">Don’t let the foregoing discussion give you the impression that finding optimal algorithms is always easy. It isn’t. In fact, there are many important questions in computational complexity theory that nobody knows how to answer. One famous example is the question, “Does <i>P</i> equal <i>NP</i>?” We’ll try to explore this question meaningfully without wading too deeply into the technical details.</p>
<p class="indent">The class <i>P</i> is the collection of all problems that can be solved with an algorithm whose complexity is, at most, polynomial: Θ(<i>n<sup>r</sup></i>) for some <i>r</i>. Many of the problems we have seen, including searching and sorting, belong to the class <i>P</i>, because we have solved them using polynomial-time algorithms.</p>
<p class="indent">The class <i>NP</i> is the collection of all problems whose solution can be <i>checked</i> (but not necessarily <i>found</i>) in polynomial time.<sup><a id="rch5fn4" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fn4" class="totri-footnote">4</a></sup> One example of a problem in <i>NP</i> is the task of finding a Hamilton circuit in a graph. It is easy to check that a given circuit is Hamiltonian, but it isn’t always easy to find such a circuit. Another example is determining whether a given integer <i>n</i> is composite; you can easily check to see if <i>d</i> divides <i>n</i>, but it may take a long time to find <i>d</i>.</p>
<p class="indent">A problem <i>x</i> in <i>NP</i> is called <i>NP-complete</i> if a polynomial-time solution to <i>x</i> would yield a polynomial-time solution to <i>any</i> problem in <i>NP</i>. So <i>NP</i>-complete <span epub:type="pagebreak" id="page_346"></span>problems are in a sense the hardest problems in <i>NP</i>; solving just one of them would solve all the others. The following are some well-known <i>NP</i>-complete problems.</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Does a given graph have a Hamilton circuit?</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Can the vertices of a given graph be colored with a given number of colors?</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Can the variables in a given formula in propositional logic be given true/false values that will make the value of the formula true?</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Given a set <i>U</i> of integers, is there some subset of <i>U</i> whose elements add up to 0?</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Given two graphs <i>G</i><sub>1</sub> and <i>G</i><sub>2</sub>, is <i>G</i><sub>1</sub> isomorphic to a subgraph of <i>G</i><sub>2</sub>?</p>
<p class="indentt">Hundreds of other problems are known to be <i>NP</i>-complete. If someone could find a polynomial-time algorithm to solve any one of them, there would be a polynomial-time solution to all problems in <i>NP</i>. In other words, <i>P</i> would equal <i>NP</i>. But, to date, nobody has found such an algorithm. Mathematicians today generally suspect that <i>P</i> ≠ <i>NP</i>, but a valid proof of this assertion has never been found. This is arguably the greatest open question in modern mathematics.<sup><a id="rch5fn5" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fn5" class="totri-footnote">5</a></sup></p>
<p class="border"></p>
<p class="border1"></p>
<p class="h3"><a id="ch5exe4"></a>Exercises 5.4</p>
<p class="numlist">1.&nbsp;&nbsp;Use a decision tree to describe an optimal procedure for identifying a bird <i>B</i> from among the six species below, using “yes or no” questions only. Explain how you know that your procedure is optimal.</p>
<table class="table">
<tbody><tr>
<td class="left" style="width:50%;"><span class="blue"><b>Species</b></span></td>
<td class="left1" style="width:50%;"><span class="blue"><b>Facts</b></span></td>
</tr>
<tr>
<td class="centerlbt"></td>
<td class="center1t"></td>
</tr>
<tr>
<td class="centerlb-r">Yellow Warbler</td>
<td class="left1">Mostly yellow, no cap.</td>
</tr>
<tr>
<td class="centerlb-r">Wilson’s Warbler</td>
<td class="left1">Mostly yellow, black cap, olive back.</td>
</tr>
<tr>
<td class="centerlb-r">American Goldfinch</td>
<td class="left1">Mostly yellow, black cap, yellow back.</td>
</tr>
<tr>
<td class="centerlb-r">Oak Titmouse</td>
<td class="left1">Mostly gray, with a crest.</td>
</tr>
<tr>
<td class="centerlb-r">Hutton’s Vireo</td>
<td class="left1">Mostly gray, olive back, no crest.</td>
</tr>
<tr>
<td class="centerlb-rs">Blue-gray Gnatcatcher</td>
<td class="left1s">Mostly gray, dark gray back, no crest.</td>
</tr>
</tbody></table>
<p class="numlist"><span epub:type="pagebreak" id="page_347"></span>2.&nbsp;&nbsp;Consider the following (rather inelegant) algorithm for printing three numbers in increasing order.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo18"></a><b>Algorithm 5.18</b> Printing three numbers in order by brute force.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>a, b, c</i> ∈ <b>R</b>.</p>
<p class="hang3">Postconditions: The elements of {<i>a, b, c</i>} are printed in increasing order.</p>
<p class="mathet"><code>if</code> <i>a</i> &lt; <i>b</i> <code>then</code></p>
<p class="mathe1"><span class="mat1">⌜</span> <code>if</code> <i>b</i> &lt; <i>c</i> <code>then</code></p>
<p class="mathe2a"><code>print</code> <i>a, b, c</i></p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <code>if</code> <i>a</i> &lt; <i>c</i> <code>then</code></p>
<p class="mathe2c"><code>print</code> <i>a, c, b</i></p>
<p class="mathe2b"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌞</span>&nbsp;&nbsp;<span class="mat1">⌞</span>&nbsp;&nbsp;<code>print</code> <i>c, a, b</i></p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌜</span> <code>if</code> <i>a</i> &lt; <i>c</i> <code>then</code></p>
<p class="mathe2a"><code>print</code> <i>b, a, c</i></p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <code>if</code> <i>b</i> &lt; <i>c</i> <code>then</code></p>
<p class="mathe2c"><code>print</code> <i>b, c, a</i></p>
<p class="mathe2b"><code>else</code></p>
<p class="mathe1"><span class="mat1">⌞</span>&nbsp;&nbsp;<span class="mat1">⌞</span>&nbsp;&nbsp;<code>print</code> <i>c, b, a</i></p>
<p class="linetb"></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Draw a decision tree to model the choices made by this algorithm.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Is this algorithm optimal with respect to the number of &lt; comparisons? Explain.</p>
<p class="numlist">3.&nbsp;&nbsp;In a collection of 10 coins, 4 coins are counterfeit and weigh less than the genuine coins. Find a good lower bound on the number of balance scale weighings needed to identify all the fake coins. (Assume the balance scale has three states: tilted left, tilted right, or balanced.)</p>
<p class="numlist">4.&nbsp;&nbsp;Consider the problem of identifying a counterfeit coin with a balance scale. Suppose, as we did in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex18">Example 5.18</a>, that 1 coin out of a set of 10 is fake, but this time suppose that the fake coin could be <i>either</i> too heavy or too light, and it must be determined which is the case. What does <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> say about the minimum number of weighings in this case?</p>
<p class="numlist">5.&nbsp;&nbsp;In a collection of 200 coins, one is counterfeit and weighs either more or less than the genuine coins. Find a good lower bound on the number of balance scale weighings needed to identify the fake coin and determine whether it is too heavy or too light. Assume the balance scale has three states: tilted left, tilted right, or balanced.</p>
<p class="numlist"><span epub:type="pagebreak" id="page_348"></span>6.&nbsp;&nbsp;Suppose that one coin in a set of eight coins is fake, and that the fake coin is lighter than the other coins.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> to find a lower bound on the number of balance-scale weighings needed to identify the fake.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Find a strategy that identifies the fake coin in the optimal number of weighings. Draw a decision tree to show how your strategy works.</p>
<p class="numlist">7.&nbsp;&nbsp;Suppose that 1 coin out of a set of 16 is fake and has a different weight than the others. Instead of a balance scale with three positions, you have a device that tells only whether or not two quantities weigh the same. In other words, your device has only two positions: “same” or “different.”</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> to find a lower bound on the number of times you need to use this device to identify the fake.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Find a strategy that identifies the fake coin in the optimal number of weighings. Draw a decision tree to show how your strategy works.</p>
<p class="numlist">8.&nbsp;&nbsp;Let <i>X</i> be a set of <i>n</i> natural numbers. Consider the task of finding a pair of numbers in <i>X</i> whose difference is 100. Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> to find a lower bound on the worst-case number of binary comparisons needed to accomplish this task. Give an exact answer, and also a big-Θ estimate.</p>
<p class="numlist">9.&nbsp;&nbsp;A string of 24 Christmas lights has one defective bulb and one special bulb. The string of lights can be tested by removing any subset of the 24 bulbs and leaving the rest connected. If the defective bulb is connected, none of the lights will work. If the special bulb is connected (and the defective one is not), then all of the bulbs will blink. If neither the defective nor the special bulb is connected, all of the bulbs will light up normally. Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> to find a good lower bound for the number of tests needed to identify the defective bulb and the special bulb. Explain your reasoning. (Don’t draw the whole tree!)</p>
<p class="numlistm">10.&nbsp;&nbsp;Consider the task of selecting a person at random from a group of <i>n</i> people by repeatedly rolling a single six-sided die.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Use <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5the1">Theorem 5.1</a> to find a lower bound on the worst-case number of rolls needed to select a person from a group of <i>n</i> = 72 people.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Describe an optimal algorithm for selecting a person from a group of <i>n</i> = 72 people.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;What is the greatest value of <i>n</i> for which a person can be selected at random using five rolls?</p>
<p class="numlistm">11.&nbsp;&nbsp;Compute the best-case number of questions answered by <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo16">Algorithms 5.16</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">5.17</a>.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_349"></span>12.&nbsp;&nbsp;Compute the average-case number of questions answered by <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo16">Algorithms 5.16</a> and <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo17">5.17</a>. Assume that each of the four species is equally likely to occur.</p>
<p class="numlistm">13.&nbsp;&nbsp;Consider the problem of searching for a target element in an ordered list. Is the sequential search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>) asymptotically optimal? Why or why not?</p>
<p class="numlistm">14.&nbsp;&nbsp;Is the Bubble Sort asymptotically optimal? Why or why not?</p>
<p class="numlistm">15.&nbsp;&nbsp;The Quick Sort is a recursive sorting algorithm that has average-case complexity Θ(<i>n</i>log<sub>2</sub> <i>n</i>) and worst-case complexity Θ(<i>n</i><sup>2</sup>). Is the Quick Sort asymptotically optimal? Why or why not?</p>
<p class="numlistm">16.&nbsp;&nbsp;Refer to Exercise 15 of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub3">Section 5.3</a>. Consider the general problem of finding the shortest directed path from some <i>A</i> ∈ {<i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub>, <i>A</i><sub>4</sub>} and ending at some <i>B<sub>i</sub></i> in a weighted directed graph of the following form, where the graph is <i>n</i> edges wide (instead of 3 edges wide, as in Exercise 15). (The weights of this graph are not shown below.)</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig349-1.png" alt="Image" width="916" height="316" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig349-1.png"></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;In terms of <i>n</i>, how many different directed paths are there that start at a given <i>A</i> ∈ {<i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub>, <i>A</i><sub>4</sub>} and end at the rightmost column (at any <i>B<sub>i</sub></i>)?</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Give a good lower bound on the number of two-way comparisons required by any algorithm that finds the overall shortest directed path from the <i>A</i> column to the <i>B</i> column. Give an exact answer in terms of <i>n</i>, and also give a big-Θ estimate for your answer.</p>
<p class="numlistm">17.&nbsp;&nbsp;Prove <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5lem1">Lemma 5.1</a> using induction on <i>p</i>.</p>
<p class="numlistm">18.&nbsp;&nbsp;Suppose <i>s</i> and <i>t</i> are two strings of length 5 in the alphabet <code>a</code> … <code>z</code>. An algorithm checks to see if <i>s</i> = <i>t</i> by comparing corresponding symbols in each string, from left to right. Draw the decision tree that models this algorithm.</p>
<p class="numlistm">19.&nbsp;&nbsp;Does the set</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq349-1.png" alt="Image" width="475" height="29" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq349-1.png"></p>
<p class="numlistpara1">have a subset whose elements add up to 0? If so, find such a subset. If not, explain why not.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_350"></span>20.&nbsp;&nbsp;Suppose <i>U</i> is a set of <i>n</i> integers. Approximate the worst-case complexity of an algorithm that runs through all possible subsets of <i>U</i> and adds up the elements in each subset to see if there is a subset whose elements add up to 0.</p>
<p class="numlistm">21.&nbsp;&nbsp;Is there an assignment of true/false values for the variables <i>p, q, r, s</i>, and <i>t</i> such that the formula</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq350-1.png" alt="Image" width="559" height="29" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq350-1.png"></p>
<p class="numlistpara1">takes the value true? If so, find such an assignment. If not, explain why not.</p>
<p class="numlistm">22.&nbsp;&nbsp;Suppose <i>P</i> is a formula in propositional logic containing <i>n</i> variables. Approximate the worst-case complexity of an algorithm that runs through all possible true/false values of the <i>n</i> variables to see if there is an assignment that makes <i>P</i> true.</p>
<p class="numlistm">23.&nbsp;&nbsp;Let <i>G</i><sub>1</sub> and <i>G</i><sub>2</sub> be graphs with vertex sets <i>V</i><sub>1</sub> and <i>V</i><sub>2</sub>, respectively, with |<i>V</i><sub>1</sub>| = |<i>V</i><sub>2</sub>| = <i>n</i>. Approximate the worst-case complexity of an algorithm that runs through all possible one-to-one correspondences <i>V</i><sub>1</sub> → <i>V</i><sub>2</sub> to see if there is an isomorphism <i>G</i><sub>1</sub> <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in350-1.png" alt="Image" width="40" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in350-1.png"> <i>G</i><sub>2</sub>.</p>
<p class="h1"><a id="ch5sub5"></a><b>5.5&nbsp;&nbsp;&nbsp;Program Verification</b></p>
<p class="noindent">Up to this point, we have been using preconditions and postconditions to describe what a given algorithm is supposed to do. This is good practice, because it gives a mathematically precise way of summarizing the work of a segment of pseudocode. However, aside from appealing to intuition and “common sense,” we have not yet proved that any of our preconditions and postconditions accurately describe their algorithms. In this section and the next, we will learn how to write mathematical proofs of correctness to verify that a given algorithm works according to its specifications.</p>
<div class="box">
<p class="noindent1"><b>Inquiry 5.12</b> Suppose you have a stack of two boxes, a small one on top of a larger one. There are three platforms capable of bearing the weight of the boxes, and you want to move the stack to the third platform. However, you can move only one box at a time, and you can’t put the big box on top of the smaller one. Find a sequence of moves to accomplish this task. Invent your own notation to represent your sequence.</p>
<p class="image-2"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig350-1.png" alt="Image" width="431" height="113" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig350-1.png"></p>
</div>
<div class="box">
<p class="noindent1"><span epub:type="pagebreak" id="page_351"></span><b>Inquiry 5.13</b> Now suppose you have a stack of three boxes, and you want to move the stack to the third platform under the same constraints as in Inquiry Problem 5.12: move one box at a time, and never put a box on one that is smaller. Find an appropriate sequence of moves.</p>
<p class="image-2"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis351-1.png" alt="Image" width="492" height="136" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis351-1.png"></p>
</div>
<p class="h2"><a id="ch5sub5sub1"></a><b>5.5.1&nbsp;&nbsp;&nbsp;Verification vs. Testing</b></p>
<p class="noindent">Generally speaking, there are two ways to check that an algorithm will behave properly. The first, and most common, is <i>program testing</i>. We enter our algorithm into a computer, enter some data that satisfies the preconditions, and check to see if the output satisfies the postconditions. Programmers always test their programs; they try to concoct as many different kinds of sets of input data as needed to convince themselves that their program works. The problem with program testing is that it can never, with 100% certainty, tell you that a program will always work (unless you are able to test every possible data set—an unlikely circumstance).</p>
<p class="indent">The second method, <i>program verification</i>, tells us more than testing can tell us: it gives a mathematical proof that, no matter what data is input into the program, the output will always satisfy the postconditions.</p>
<p class="indent">It is always better to verify than to test. Unfortunately, program verification is hard, except for small, self-contained routines. The primary value of learning program verification lies in applying logical thinking to algorithms. A programmer who understands program verification is more likely to write correct code.</p>
<p class="indent">Recall from <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub1">Section 5.1</a> that an algorithm is <i>correct</i> if</p>
<p class="image">Preconditions ⇒ Postconditions,</p>
<p class="noindent">where the preconditions are evaluated before program execution, and the postconditions are evaluated after. Therefore, to prove that an algorithm is correct, you assume the preconditions as given, and you try to deduce the postconditions by analyzing the code.</p>
<p class="h2"><a id="ch5sub5sub2"></a><b>5.5.2&nbsp;&nbsp;&nbsp;Verifying Recursive Algorithms</b></p>
<p class="noindent">Recursive algorithms can be easy to verify if you understand induction. The examples in this section should remind you of the proofs in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml">Chapter 3</a>. In fact, the following example first appeared in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3sub4">Section 3.4</a>, only with different notation.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_352"></span><a id="ch5ex19"></a><b><span class="blue">Example 5.19</span></b> Prove that the string reversal algorithm of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex6">Example 5.6</a> is correct.</p>
<p class="noindentt"><i>Solution:</i> In order to write a proof of correctness, we need to state the preconditions and postconditions.</p>
<p class="noindentt">&nbsp;Preconditions: <i>s</i> = <i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> ··· <i>c<sub>n</sub></i> is a string, possibly empty.</p>
<p class="noindentt">&nbsp;Postconditions: <code>Reverse</code>(<i>s</i>) = <i>c<sub>n</sub> c</i><sub><i>n</i>−1</sub> <i>c</i><sub><i>n</i>−2</sub> ··· <i>c</i><sub>2</sub><i>c</i><sub>1</sub>.</p>
<p class="noindentt">Before looking at the proof, let’s remind ourselves about mathematical induction. The preconditions and postconditions are statements about a string of length <i>n</i>, so it seems natural to do induction on <i>n</i>. We are trying to conclude the postconditions, so the base case needs to check the postconditions for the string with <i>n</i> = 0 symbols—the empty string <i>λ</i>.</p>
<p class="blockquote">Base Case: <code>Reverse</code>(<i>λ</i>) = <i>λ</i>.</p>
<p class="noindentt">The inductive hypothesis looks like the statement we are trying to prove, but with <i>n</i> replaced by <i>k</i> − 1.</p>
<p class="blockquote">Inductive Hypothesis: If <i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> ··· <i>c</i><sub><i>k</i>−1</sub> is a string of length <i>k</i> − 1 for some <i>k</i> &gt; 0, then <code>Reverse</code>(<i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> ··· <i>c</i><sub><i>k</i>−1</sub>) = <i>c</i><sub><i>k</i>−1</sub> ··· <i>c</i><sub>2</sub><i>c</i><sub>1</sub>.</p>
<p class="noindentt">Once we have proved the base case and stated the inductive hypothesis, all that is left to do is to prove the postconditions for <i>n</i> = <i>k</i>.</p>
<p class="blockquote">Need to Show: <code>Reverse</code>(<i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> ··· <i>c<sub>k</sub></i>) = <i>c<sub>k</sub></i> ··· <i>c</i><sub>3</sub><i>c</i><sub>2</sub><i>c</i><sub>1</sub>.</p>
<p class="noindentt">Now that we have identified these key parts, writing down the inductive proof is fairly straightforward.</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;We use induction on <i>n</i>, the length of the string. If <i>n</i> = 0, <i>s</i> = <i>λ</i>, the empty string. In this case, the first return statement is executed, and the function returns <i>λ</i>, the correct reversal of itself. In other words,</p>
<p class="image"><code>Reverse</code>(λ) = λ.</p>
<p class="noindent">Suppose as inductive hypothesis that, for any string of length <i>k</i> − 1,</p>
<p class="image"><code>Reverse</code>(<i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> … <i>c</i><sub><i>k</i>−1</sub>) = <i>c</i><sub><i>k</i>−1</sub><i>c</i><sub><i>k</i>−2</sub> … <i>c</i><sub>2</sub><i>c</i><sub>1</sub></p>
<p class="noindent">for some <i>k</i> &gt; 0. Now suppose <code>Reverse</code> is sent a string of length <i>k</i>.</p>
<table class="table1">
<tbody><tr>
<td class="td-r" style="width:30%;"><code>Reverse</code>(<i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> … <i>c</i><sub><i>k</i>−1</sub><i>c<sub>k</sub></i>)</td>
<td class="td-r" style="width:70%;">= <i>c<sub>k</sub></i> <code>Reverse</code>(<i>c</i><sub>1</sub><i>c</i><sub>2</sub><i>c</i><sub>3</sub> … <i>c</i><sub><i>k</i>−1</sub>) using the algorithm</td>
</tr>
<tr>
<td></td>
<td class="td-r">= <i>c<sub>k</sub> c<sub>k − 1</sub>c<sub>k − 2</sub></i> … <i>c</i><sub>2</sub><i>c</i><sub>1</sub> by inductive hypothesis</td>
</tr>
</tbody></table>
<p class="noindentt">as required.</p>
<p class="right1">□</p>
<p class="indentt">Compare this proof with the proof of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3the4">Theorem 3.4</a>.</p>
<p class="right">◊</p>
<p class="indent"><span epub:type="pagebreak" id="page_353"></span>Our first look at inductive proofs was back in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3sub2">Section 3.2</a>, where we used induction to verify a closed-form solution to a recurrence relation. The following example recasts such a proof in the language of algorithms.</p>
<p class="noindentt"><a id="ch5ex20"></a><b><span class="blue">Example 5.20</span></b> Prove the correctness of the following algorithm for computing the Triangular Numbers.</p>
<p class="noindentt">&nbsp;Preconditions: <i>n</i> ≥ 1.</p>
<p class="noindentt">&nbsp;Postconditions: <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in353-1.png" alt="Image" width="274" height="56" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in353-1.png"></p>
<p class="mathet"><code>function Trinum</code>(<i>n</i> ∈ <b>N</b>)</p>
<p class="mathe1"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2"><code>return</code> 1</p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><code>return</code> <i>n</i> + <code>Trinum</code>(<i>n</i> − 1)</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;(Induction on <i>n</i>.) Since <code>Trinum</code>(1) = 1 = (1 + 1)/2, the postconditions hold when <i>n</i> = 1. Suppose as inductive hypothesis that</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis353-2.png" alt="Image" width="370" height="66" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis353-2.png"></p>
<p class="noindent">for some <i>k</i> &gt; 1. Then</p>
<table class="table1">
<tbody><tr>
<td class="td-r"><code>Trinum</code>(<i>k</i>)</td>
<td class="td-r">= <i>k</i> + <code>Trinum</code>(<i>k</i> − 1)</td>
<td class="td-r">using algorithm</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <i>k</i> + (<i>k</i> − 1)(<i>k</i>)/2</td>
<td class="td-r">by inductive hypothesis</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= (2<i>k</i> + <i>k</i><sup>2</sup> − <i>k</i>)/2<br>= <i>k</i>(<i>k</i> + 1)/2</td>
<td class="td-r"></td>
</tr>
</tbody></table>
<p class="noindent">as required.</p>
<p class="right">□</p>
<p class="indentt">To get started with an inductive proof, you need to identify the variable on which to perform the induction. Notice that in both of the preceding examples, this variable measures the size of the input. This is typically the case; remember that inductive arguments are appropriate for proving assertions of the form</p>
<p class="image">Statement(<i>n</i>) for all <i>n</i>.</p>
<p class="noindent">When the input to an algorithm depends on <i>n</i>, the statement</p>
<p class="image">Preconditions ⇒ Postconditions</p>
<p class="noindent">will usually be of this form.</p>
<p class="h2"><a id="ch5sub5sub3"></a><span epub:type="pagebreak" id="page_354"></span><b>5.5.3&nbsp;&nbsp;&nbsp;Searching and Sorting</b></p>
<p class="noindent">We now have enough tools at our disposal to look at two important divide-and-conquer algorithms—the binary search and the merge sort—from the point of view of program correctness.</p>
<p class="indent">The next example is a little tricky. Although the size <i>n</i> of the set <i>X</i> is specified in the preconditions, the postconditions make a claim about a subset {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>} ⊆ <i>X</i>. The size of this subset, <i>r</i> − <i>l</i> + 1, is the quantity on which we perform the induction.</p>
<p class="noindentt"><a id="ch5ex21"></a><b><span class="blue">Example 5.21</span></b> Prove the correctness of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo4">Algorithm 5.4</a>, the recursive binary search. (The algorithm is copied below for convenience.)</p>
<p class="hang3">Preconditions: The set <i>U</i> is totally ordered by &lt;, and <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <i>U</i>, with</p>
<p class="image"><i>x</i><sub>1</sub> &lt; <i>x</i><sub>2</sub> &lt; … &lt; <i>x</i><sub>n</sub></p>
<p class="indent">&nbsp;&nbsp;and <i>t</i> ∈ <i>U</i>. Also, 1 ≤ <i>l</i> ≤ <i>r</i> ≤ <i>n</i>.</p>
<p class="hang3">Postconditions: <code>BinSearch</code>(<i>t, X, l, r</i>) = (<i>t</i> ∈ {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>})</p>
<p class="mathet"><code>function BinSearch</code>(<i>t</i> ∈ <i>U</i>,</p>
<p class="mathe2e">&nbsp;<i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <i>U</i>,</p>
<p class="mathe2e">&nbsp;<i>l, r</i> ∈ {1,2, …, <i>n</i>})</p>
<p class="mathe2"><i>i</i> ← ⌊(<i>l</i> + <i>r</i>)/2⌋</p>
<p class="mathe2"><code>if</code> <i>t</i> = <i>x<sub>i</sub></i> <code>then</code></p>
<p class="mathe2a"><code>return true</code></p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <code>if</code> (<i>t</i> &lt; <i>x<sub>i</sub></i>) ∧ (<i>l</i> &lt; <i>i</i>) <code>then</code></p>
<p class="mathe2c"><code>return BinSearch</code>(<i>t, X, l, i</i> − 1)</p>
<p class="mathe2b"><code>else</code></p>
<p class="mathe2c"><span class="mat1">⌜</span> <code>if</code> (<i>t</i> &gt; <i>x<sub>i</sub></i>) ∧ (<i>i</i> &lt; <i>r</i>) <code>then</code></p>
<p class="mathe2e"><code>return BinSearch</code>(<i>t, X, i</i> + 1, <i>r</i>)</p>
<p class="mathe2d"><code>else</code></p>
<p class="mathe2a"><span class="mat1">⌞</span>&nbsp;&nbsp;<span class="mat1">⌞</span>&nbsp;&nbsp;<code>return false</code></p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;We use induction on <i>r</i> − <i>l</i> + 1, the size of the list. If the list contains one element, then <i>l</i> = <i>r</i>, so <i>i</i> is set to <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in354-1.png" alt="Image" width="134" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in354-1.png">. If <i>t</i> = <i>x<sub>l</sub></i>, the function returns true. If not, the comparisons <i>l</i> &lt; <i>i</i> and <i>i</i> &lt; <i>r</i> will fail, so the function will return false. In other words,</p>
<p class="image"><code>BinSearch</code>(<i>t, X, l, r</i>) = (<i>t</i> ∈ {<i>x</i><sub>l</sub>}),</p>
<p class="noindent">so the algorithm is correct for lists of size 1. Suppose, as inductive hypothesis, that the function returns true exactly when <i>t</i> is in the list, for lists of size <i>n</i> − 1 or less. In other words, suppose that</p>
<p class="image">BinSearch(<i>t, X, l, r</i>) = (<i>t</i> ∈ {<i>x</i><sub>l</sub>, <i>x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>})</p>
<p class="noindent"><span epub:type="pagebreak" id="page_355"></span>for any <i>l, r</i> satisfying <i>r</i> − <i>l</i> + 1 <i>&lt; n</i>. Given a list <i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i> with <i>r</i> − <i>l</i> + 1 = <i>n</i>, the function will return true if <i>x<sub>i</sub></i> = <i>t</i>, where <i>i</i> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in330-1.png" alt="Image" width="104" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in330-1.png">. If <i>t</i> &lt; <i>x<sub>i</sub></i>, we know that <i>t</i> is in the list if and only if it is in {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x</i><sub><i>i</i>−1</sub>}. In this case</p>
<table class="table1">
<tbody><tr>
<td class="td-r"><code>BinSearch</code>(<i>t, X, l, r</i>)</td>
<td class="td-r"><code>= BinSearch</code>(<i>t, X, l, i</i> − 1) by 2nd return statement</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= (<i>t</i> ∈ {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x</i><sub><i>i</i>−1</sub>}) by inductive hypothesis</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= (<i>t</i> ∈ {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>})</td>
</tr>
</tbody></table>
<p class="noindent">as required. A similar statement holds if <i>t</i> &gt; <i>x<sub>i</sub></i>.</p>
<p class="right">□</p>
<p class="indentt">This proof wasn’t easy. Writing down rigorous proofs of correctness usually takes quite a bit of work. However, we can employ the same inductive technique slightly less formally to check just one part of the specified behavior of an algorithm.</p>
<p class="noindentt"><a id="ch5ex22"></a><b><span class="blue">Example 5.22</span></b> Assuming that the <code>Merge</code> subroutine (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo11">Algorithm 5.11</a>) is correct, prove that the <code>MergeSort</code> function (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo12">Algorithm 5.12</a>) returns an ordered list.</p>
<p class="noindentta"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;We use strong induction on <i>n</i>, the size of the array to be sorted. If <i>n</i> = 1, <code>MergeSort</code> returns <i>x</i><sub>1</sub>, which is trivially in order. Suppose, as inductive hypothesis, that</p>
<p class="image"><code>MergeSort</code>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub>i</sub>)</p>
<p class="noindent">always returns an ordered list of size <i>i</i>, for any array of size <i>i</i> &lt; <i>k</i>, for some <i>k</i> &gt; 1. Given a list <i>A</i> of size <i>k</i>, <code>MergeSort</code>(<i>A</i>) returns</p>
<p class="image"><code>Merge</code>(<code>MergeSort</code>(<i>L</i>), <code>MergeSort</code>(<i>R</i>)),</p>
<p class="noindent">where <i>L</i> and <i>R</i> are lists of size less than <i>k</i>. By inductive hypothesis, <code>MergeSort</code>(<i>L</i>) and <code>MergeSort</code>(<i>R</i>) are also of size less than <i>k</i> and are ordered. Thus, the preconditions of the Merge subroutine are satisfied, so the postconditions imply that</p>
<p class="image"><code>Merge</code>(<code>MergeSort</code>(<i>L</i>), <code>MergeSort</code>(<i>R</i>))</p>
<p class="noindent">is in order, as required.</p>
<p class="right1">□</p>
<p class="indentt">Although we haven’t yet proved that the <code>Merge</code> subroutine works, we have shown that, if it does, the <code>MergeSort</code> will work also.</p>
<p class="indent">Learning to prove the correctness of recursive algorithms has an important side benefit: it develops the ability to write accurate recursive programs. For starters, the base case of a correct recursive function must satisfy the postconditions. Furthermore, any recursive call can make use of the assumption that the postconditions hold for simpler cases. For example, the call</p>
<p class="image"><code>Merge</code>(<code>MergeSort</code>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>l</i></sub>), <code>MergeSort</code>(<i>x</i><sub><i>l</i>+1</sub>, <i>x</i><sub><i>l</i>+2</sub>, …, <i>x</i><sub><i>n</i></sub>))</p>
<p class="noindent">inside the <code>MergeSort</code> function returns a sorted list, assuming that <code>MergeSort</code> works on the smaller lists. This is the crux of the above inductive argument, but it is also a key principle that guides the recursive paradigm of algorithm design.</p>
<p class="h2"><a id="ch5sub5sub4"></a><span epub:type="pagebreak" id="page_356"></span><b>5.5.4&nbsp;&nbsp;&nbsp;Towers of Hanoi</b></p>
<p class="noindent">We wrap up this section on recursion, induction, and program verification with a look at a classic mathematical puzzle: the Towers of Hanoi. This puzzle is worth pondering because it illustrates the power and elegance of recursive thinking, and because it gives us an example of an algorithm that is easy to verify, but hard to test.</p>
<p class="indent">The puzzle consists of three pegs and a stack of disks of descending sizes. (See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig16">Figure 5.16</a>.) To begin, the disks are all stacked on the leftmost peg in order of size, with the largest on the bottom. The object is to move the entire pile of disks to the rightmost peg, subject to the following rules:</p>
<p class="numlist">1.&nbsp;&nbsp;The top disk on any of the pegs may be moved to either of the other two pegs, where it then becomes the top disk.</p>
<p class="numlist">2.&nbsp;&nbsp;Only one disk may be moved at a time.</p>
<p class="numlist">3.&nbsp;&nbsp;A disk must never be placed on top of a smaller disk.</p>
<p class="indentt">In order to discuss how to solve this puzzle, we need to develop a little notation. Number the three pegs 1,2, and 3 from left to right. A single move of a disk from one peg to another can then be represented by an ordered pair (<i>p, q</i>), with {<i>p, q</i>} ⊆ {1,2,3}. For example, <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig17">Figure 5.17</a> illustrates the move sequence</p>
<p class="image">(1,2), (1,3), (2,1)</p>
<p class="noindent">in the case <i>n</i> = 4.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig356-1.png" alt="Image" width="987" height="529" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig356-1.png"></p>
<p class="figcaption"><a id="ch5fig16"></a><b><span class="blue">Figure 5.16</span></b> A version of the Towers of Hanoi puzzle with <i>n</i> = 5 disks.</p>
</div>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_357"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig357-1.png" alt="Image" width="1025" height="164" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig357-1.png"></p>
<p class="figcaption"><a id="ch5fig17"></a><b><span class="blue">Figure 5.17</span></b> This sequence of moves is denoted (1,2), (1,3), (2,1).</p>
</div>
<p class="indent">Our goal here is to write and prove the correctness of an algorithm to solve this puzzle for any value of <i>n</i>. As we think about how to write the algorithm, we can think ahead to how the inductive proof of correctness will go. The base case is easy to solve: when there is only <i>n</i> = 1 disk, we can just move it to the rightmost peg. The inductive hypothesis will be, roughly, that we can solve the puzzle for <i>n</i> = <i>k</i> − 1 disks. The trick to solving the <i>n</i> = <i>k</i> disk case is to use the <i>n</i> = <i>k</i> − 1 case to do most of the work. Suppose <i>k</i> disks are initially stacked up on peg #1.</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Move the top <i>k</i> − 1 disks from peg #1 to peg #2, using the solution for <i>n</i> = <i>k</i> − 1.</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Move the remaining disk from peg #1 to peg #3.</p>
<p class="bull1t"><span class="blue">•</span>&nbsp;&nbsp;Use the <i>n</i> = <i>k</i> − 1 case again to move the stack from peg #2 to peg #3.</p>
<p class="indentt">The formal pseudocode version of this algorithm, using the above ordered-pair notation, is shown in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo19">Algorithm 5.19</a>.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo19"></a><b>Algorithm 5.19</b> Solving the Towers of Hanoi puzzle.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>n</i> ∈ <b>N</b>, <i>p</i><sub>from</sub>, <i>p</i><sub>to</sub> ∈ {1,2,3}, <i>p</i><sub>from</sub> ≠ <i>p</i><sub>to</sub>.</p>
<p class="hang3">Postconditions: Returns a sequence of ordered pairs that represent legal moves that solve the Towers of Hanoi puzzle for <i>n</i> disks, where the disks are initially stacked on peg <i>p</i><sub>from</sub> and moved to peg <i>p</i><sub>to</sub>.</p>
<p class="mathet"><code>function Hanoi</code>(<i>n</i> ← <b>N</b>, <i>p</i><sub>from</sub>, <i>p</i><sub>to</sub> ∈ {1,2,3})</p>
<p class="mathe1"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2"><code>return</code> (<i>p</i><sub>from</sub>, <i>p</i><sub>to</sub>)</p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>p</i><sub>other</sub> ← <code>other peg (not</code> <i>p</i><sub>from</sub> <code>or</code> <i>p</i><sub>to</sub>)</p>
<p class="mathe2a"><code>return Hanoi</code>(<i>n</i> − 1, <i>p</i><sub>from</sub>, <i>p</i><sub>other</sub>),</p>
<p class="mathe2e">(<i>p</i><sub>from</sub>, <i>p</i><sub>to</sub>),</p>
<p class="mathe2"><span class="mat1">⌞</span>&nbsp;&nbsp;&nbsp;<code>Hanoi</code>(<i>n</i> − 1, <i>p</i><sub>other</sub>, <i>p</i><sub>to</sub>)</p>
<p class="linetb"></p>
<p class="indent"><span epub:type="pagebreak" id="page_358"></span>The following top-down evaluation tests this algorithm for the case <i>n</i> = 2. Initially, the two disks are stacked on peg #1.</p>
<table class="table1">
<tbody><tr>
<td class="td-r"><code>Hanoi</code>(2, 1, 3)</td>
<td class="td-r">= <code>Hanoi</code>(1,1,2), <code></code>(1,3), <code>Hanoi</code>(1,2,3)</td>
</tr>
<tr>
<td class="td-r"></td>
<td class="td-r">= <code></code>(1,2), <code></code>(1,3), <code></code>(2,3)</td>
</tr>
</tbody></table>
<p class="noindent">This sequence of moves does, in fact, solve the puzzle for the <i>n</i> = 2 case. Testing the <i>n</i> = 3 case is left as an exercise, as well as proving the correctness of this algorithm for all <i>n</i>.</p>
<p class="indent">Another exercise will ask you to verify that this function always returns a sequence of 2<i><sup>n</sup></i> − 1 moves. So, for example, our algorithm will require</p>
<p class="image">1,267,650,600,228,229, 401, 496,703,205,375</p>
<p class="noindent">moves to solve the puzzle in the case of <i>n</i> = 100 disks. Suppose (generously) that a computer is able to produce and check this sequence at a speed of one nanosecond per move. Such a test would take about 40 trillion years! This calculation illustrates the power of program verification. Testing this program—even for relatively small values of <i>n</i>—is practically impossible, but proving its correctness for <i>all</i> values of <i>n</i> is easy to do.</p>
<p class="border"></p>
<p class="border1"></p>
<p class="h3"><a id="ch5exe5"></a>Exercises 5.5</p>
<p class="numlist">1.&nbsp;&nbsp;Can program testing ever prove that an algorithm is <i>not</i> correct? Explain.</p>
<p class="numlist">2.&nbsp;&nbsp;The proof of correctness of the <code>Reverse</code> algorithm in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex19">Example 5.19</a> uses different notation than the proof of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3the4">Theorem 3.4</a>. What else is different about these two proofs?</p>
<p class="numlist">3.&nbsp;&nbsp;See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex21">Example 5.21</a>. What kind of induction (simple or strong) does the proof of correctness of the binary search algorithm use? Explain.</p>
<p class="numlist">4.&nbsp;&nbsp;Suppose a recursive function <code>Median</code>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> ∈ <b>R</b>) has the following preconditions and postconditions.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> ∈ <b>R</b>.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: Returns the median of <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>.</p>
<p class="numlistpara1">Answer the following questions regarding a possible proof of correctness by induction.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;What is the base case?</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;What is the inductive hypothesis, assuming the proof uses simple induction?</p>
<p class="loweralpha1"><span epub:type="pagebreak" id="page_359"></span>(c)&nbsp;&nbsp;What is the inductive hypothesis for strong induction?</p>
<p class="loweralpha1">(d)&nbsp;&nbsp;What would you then have to show to finish the proof?</p>
<p class="numlist">5.&nbsp;&nbsp;Let <i>U</i> be a set whose elements can be put into a binary search tree. A recursive function <code>MakeTree</code>(<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>, …, <i>u<sub>n</sub></i> ∈ <i>U</i>) for making a binary search tree has the following preconditions and postconditions.</p>
<p class="numlistpara1">Preconditions: <i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>, …, <i>u<sub>n</sub></i> ∈ <i>U</i>.</p>
<p class="numlistpara1">Postconditions: Returns a binary search tree whose nodes are <i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>, …, <i>u<sub>n</sub></i>.</p>
<p class="numlistpara1">Answer the following questions regarding a possible proof of correctness by induction.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;What is the base case?</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;What is the inductive hypothesis for simple induction?</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;What is the inductive hypothesis for strong induction?</p>
<p class="loweralpha1">(d)&nbsp;&nbsp;What would you then have to show to finish the proof?</p>
<p class="numlist">6.&nbsp;&nbsp;Prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> is an odd natural number.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in359-1.png" alt="Image" width="279" height="65" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in359-1.png"></p>
<p class="mathe2t"><code>function Square</code>(<i>n</i> ∈ <b>N</b>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2b"><code>return</code> 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> <i>n</i> + <code>Square</code>(<i>n</i> − 2)</p>
<p class="numlist">7.&nbsp;&nbsp;Prove the correctness of the following algorithm.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ≥ 1.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <code>P</code>(<i>n</i>) = (<i>n</i><sup>2</sup> + <i>n</i>)/2.</p>
<p class="mathe2t"><code>function P</code>(<i>n</i> ∈ <b>N</b>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2b"><code>return</code> 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> <i>n</i> + <code>P</code>(<i>n</i> − 1)</p>
<p class="numlist"><span epub:type="pagebreak" id="page_360"></span>&nbsp;&nbsp;8.&nbsp;&nbsp;Prove the correctness of the following algorithm.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ≥ 1.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <code>MyNum</code>(<i>n</i>) = 2<i><sup>n</sup></i> − 1.</p>
<p class="mathe2t"><code>function MyNum</code>(<i>n</i> ∈ <i>N</i>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2b"><code>return</code> 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> 2 · <code>MyNum</code>(<i>n</i> − 1) + 1</p>
<p class="numlist">9.&nbsp;&nbsp;Prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ≥ 0.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in360-1.png" alt="Image" width="205" height="61" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in360-1.png">.</p>
<p class="mathe2t"><code>function P</code>(<i>n</i> ∈ <b>Z</b>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 0 <code>then</code></p>
<p class="mathe2b"><code>return</code> 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> 1 + <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in102-1.png" alt="Image" width="11" height="33" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in102-1.png"> · <code>P</code>(<i>n</i> – 1)</p>
<p class="numlistm">10.&nbsp;&nbsp;In Exercise 22 of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub1">Section 5.1</a>, you wrote a pseudocode version of the recurrence relation for the hexagonal numbers, and you gave descriptive preconditions and postconditions. Prove that your algorithm is correct.</p>
<p class="numlistm">11.&nbsp;&nbsp;Prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> = 2<i><sup>p</sup></i> for some integer <i>p</i> ≥ 0.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <code>PLog</code>(<i>n</i>) = log<sub>2</sub> <i>n</i>.</p>
<p class="mathe2t"><code>function PLog</code>(<i>n</i> ∈ <b>N</b>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2b"><code>return</code> 0</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> 1 + <code>PLog</code>(<i>n</i>/2)</p>
<p class="numlist1bt"><span epub:type="pagebreak" id="page_361"></span>*12.&nbsp;&nbsp;Prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ≥ 1.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <code>ILog</code>(<i>n</i>) = ⌊log<sub>2</sub> <i>n</i>⌋.</p>
<p class="mathe2t"><code>function ILog</code>(<i>n</i> ∈ <b>N</b>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 1 <code>then</code></p>
<p class="mathe2b"><code>return</code> 0</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> 1 + <code>ILog</code>(⌊<i>n</i>/2⌋)</p>
<p class="numlistm">13.&nbsp;&nbsp;Prove that the following algorithm for computing powers is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ≥ 0, <i>x</i> ∈ <b>R</b>.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <code>Power</code>(<i>x, n</i>) = <i>x<sup>n</sup></i>.</p>
<p class="mathe2t"><code>function Power</code>(<i>x</i> ← <i>R, n</i> ∈ <i>Z</i>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 0 <code>then</code></p>
<p class="mathe2b"><code>return</code> 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><code>return</code> <i>x</i> · <code>Power</code>(<i>x, n</i> − 1)</p>
<p class="numlistm">14.&nbsp;&nbsp;The following algorithm is a “quicker” version of the algorithm in Problem 13. Notice that the preconditions and postconditions are the same. Prove that this faster algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ≥ 0, <i>x</i> ∈ <b>R</b>.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <code>QPower</code>(<i>x, n</i>) = <i>x<sup>n</sup></i>.</p>
<p class="mathe2t"><code>function QPower</code>(<i>x</i> ∈ <i>R, n</i> ∈ <i>Z</i>)</p>
<p class="mathe2a"><code>if</code> <i>n</i> = 0 <code>then</code></p>
<p class="mathe2b"><code>return</code> 1</p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <code>if</code> <i>n</i> <code>is even then</code></p>
<p class="mathe2d"><code>return (QPower</code>(<i>x, n</i>/2<code>))</code><sup>2</sup></p>
<p class="mathe2c"><code>else</code></p>
<p class="mathe2b"><span class="mat1">⌞</span>&nbsp;&nbsp;<code>return</code> <i>x</i> · <code>(QPower</code>(<i>x</i>, ⌊<i>n</i>/2⌋<code>))</code><sup>2</sup></p>
<p class="numlistm">15.&nbsp;&nbsp;Refer to the algorithms in Problems 13 and 14. Use top-down evaluations to compute the following.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;<code>Power</code>(2,10)</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;<code>QPower</code>(2,10)</p>
<p class="numlistm">16.&nbsp;&nbsp;Prove that the preorder traversal of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo5">Algorithm 5.5</a> visits every node in the tree exactly once.</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_362"></span>17.&nbsp;&nbsp;Prove that the <code>FindMax</code> function of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo10">Algorithm 5.10</a> is correct.</p>
<p class="numlistm">18.&nbsp;&nbsp;Prove that the following recursive sequential search algorithm is correct.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo20"></a><b>Algorithm 5.20</b> Recursive Sequential Search.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: The set <i>U</i> is totally ordered by &lt;, and <i>X</i> = {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} is a (possibly empty) subset of <i>U</i>.</p>
<p class="hang3">Postconditions: <code>RSearch</code>(<i>t, X</i>) = <code></code>(<i>t</i> ∈ <i>X</i>).</p>
<p class="mathe1t"><code>function RSearch</code>(<i>t ∈ U, X ⊆ U</i>)</p>
<p class="mathe2"><code>if</code> <i>X</i> = <span class="a1">∅</span> <code>then</code></p>
<p class="mathe2a"><code>return false</code></p>
<p class="mathe2"><code>else</code></p>
<p class="mathe2a"><code>return</code> (<i>t</i> = <i>x</i><sub><i>n</i></sub>) ∨ <code>RSearch</code>(<i>X</i> \ {<i>x</i><sub><i>n</i></sub>})</p>
<p class="linetb"></p>
<p class="numlistm">19.&nbsp;&nbsp;In Exercise 24 of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub2">Section 5.2</a>, you wrote a divide-and-conquer algorithm that computes the sum of all elements of a finite set <i>K</i> = {<i>k</i><sub>1</sub>, <i>k</i><sub>2</sub>, …, <i>k<sub>n</sub></i>} of integers. Prove that your algorithm is correct.</p>
<p class="numlistm">20.&nbsp;&nbsp;Prove: If <i>x</i> | <i>m</i> and <i>x</i> | (<i>n</i> mod <i>m</i>), then <i>x</i> | <i>n</i>.</p>
<p class="numlistm">21.&nbsp;&nbsp;Prove that the <code>GCD</code> function in Exercise 17 of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub1">Section 5.1</a> returns a number that divides both <i>m</i> and <i>n</i>. (Use strong induction on <i>m</i>.)</p>
<p class="numlistm">22.&nbsp;&nbsp;Test <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo19">Algorithm 5.19</a> for solving the Towers of Hanoi puzzle in the case of <i>n</i> = 3 disks using a top-down evaluation.</p>
<p class="numlistm">23.&nbsp;&nbsp;Prove the correctness of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo19">Algorithm 5.19</a>. You will need to check that the algorithm always makes legal moves, and that the returned sequence of moves represents a valid solution for all <i>n</i> ≥ 1.</p>
<p class="numlistm">24.&nbsp;&nbsp;Use a recurrence relation to show that <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo19">Algorithm 5.19</a> will always return a sequence of 2<i><sup>n</sup></i> − 1 ordered pairs.</p>
<p class="h1"><a id="ch5sub6"></a><b>5.6&nbsp;&nbsp;&nbsp;Loop Invariants</b></p>
<p class="noindent">Recursive algorithms are relatively easy to verify because it is easy to think of a recursive algorithm as a recursive definition, so it is natural to apply induction. In practice, however, iterative algorithms tend to be more common. In this section we will see how loop invariants can be used to prove the correctness of iterative algorithms. This study has an important side effect. As you begin to think more mathematically about looping structures, your ability to write accurate algorithms will improve.</p>
<div class="box">
<p class="noindent1"><span epub:type="pagebreak" id="page_363"></span><b>Inquiry 5.14</b> Tim and Kim work in an ice cream shop. At the beginning of the year, Tim makes $5 per hour and Kim makes $10 per hour. Each month, Tim gets a $0.20 raise and Kim gets a $0.40 raise. Use algebra to explain why Kim always makes twice as much as Tim.</p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.15</b> The <i>Euler characteristic χ</i> of a polygonal mesh is the number of faces minus the number of edges plus the number of vertices. For example, the triangular mesh of the octagon below has <i>χ</i> = 6 − 13 + 8 = 1. Refine this mesh by adding an edge to split one of the faces into two faces. How does the value of <i>χ</i> change? Make a conjecture.</p>
<p class="image-2"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis363-1.png" alt="Image" width="403" height="92" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis363-1.png"></p>
</div>
<div class="box">
<p class="noindent1"><b>Inquiry 5.16</b> Construct two different triangular meshes of a cube and compute the Euler characteristic <i>χ</i> of each. Make a conjecture.</p>
</div>
<p class="h2"><a id="ch5sub6sub1"></a><b>5.6.1&nbsp;&nbsp;&nbsp;Verifying Iterative Algorithms</b></p>
<p class="noindent">The basic idea behind loop invariants is simple: if we can isolate what each iteration of the loop does, then we have a good chance of knowing the cumulative effect of the loop. Stating this idea precisely takes a little bit of patience.</p>
<p class="noindentt"><a id="ch5def9"></a><b>Definition 5.9</b> Let <code>S</code> represent a segment of pseudocode inside a loop. A <i>loop invariant</i> is a predicate statement <i>P</i> in the program variables with the property that, if <i>P</i> is true before <code>S</code> executes, <i>P</i> will be true after <code>S</code> executes. More formally, let <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> be the program variables. For all <i>i</i>, let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-1.png" width="22" height="21" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-1.png"> denote the value of the program variable <i>x<sub>i</sub></i> before <code>S</code> executes, and let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-2.png" alt="Image" width="22" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-2.png"> denote the value of <i>x<sub>i</sub></i> after <code>S</code> executes. Then the predicate <i>P</i>(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>) is an invariant if</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis363-2.png" alt="Image" width="440" height="31" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis363-2.png"></p>
<p class="indent">The notation in this definition is a necessary evil. For variables that change inside the loop, we keep track of before and after values using underlines and overlines. The notation is meant to be suggestive:</p>
<p class="loweralpha1-le"><code>// assert:</code> <i>x</i> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-3.png" alt="Image" width="17" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-3.png"><br><code>pseudocode inside loop that changes the value of</code> <i>x</i><br>// <code>assert</code>: <i>x</i> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-4.png" alt="Image" width="17" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-4.png"></p>
<p class="noindentt">Think of the line (over or under) as representing the pseudocode inside the loop. Then <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-3.png" width="17" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-3.png"> is the value of <i>x</i> before executing this “line” of pseudocode, and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-4.png" alt="Image" width="17" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-4.png"> is the value after. See <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig18">Figure 5.18</a>.</p>
<div class="cap">
<p class="image"><span epub:type="pagebreak" id="page_364"></span><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig364-1.png" alt="Image" width="754" height="311" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig364-1.png"></p>
<p class="figcaptionj"><a id="ch5fig18"></a><b><span class="blue">Figure 5.18</span></b> The <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-3.png" alt="Image" width="17" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-3.png"> and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-4.png" alt="Image" width="17" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-4.png"> notation is meant to suggest when <i>x</i> is evaluated. The <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-3.png" alt="Image" width="17" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-3.png"> on the left denotes the value of <i>x</i> before the <code>pseudocode-segment</code> is executed, and the <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in363-4.png" alt="Image" width="17" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in363-4.png"> on the right denotes the value after the segment is executed. The bar in the notation represents the segment of pseudocode: <i>x</i> takes its value before (above) or after (below) the segment.</p>
</div>
<p class="indent">We use the word “invariant” because the predicate <i>P</i> stays true, no matter how many times the loop is executed. As long as <i>P</i> is true to begin with, its truth doesn’t vary, even though the values of the program variables are changing.</p>
<p class="indent">If you can show that an invariant is true before a loop starts, then it will be true after any number of iterations of the loop. In particular, the invariant will be true after the loop terminates. In other words, the invariant will give you a postcondition on the loop.</p>
<p class="indent">The hardest thing about loop invariants is finding a useful (and valid) one that yields a good postcondition. We’ll start with a simple example.</p>
<p class="noindentta"><a id="ch5ex23"></a><b><span class="blue">Example 5.23</span></b> Consider the following algorithm.</p>
<p class="mathe2t"><i>i</i> ← 0</p>
<p class="mathe2"><i>j</i> ← 0</p>
<p class="mathe2"><code>while</code> <i>i</i> &lt; <i>n</i> do</p>
<p class="mathe2c"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2c"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 2</p>
<p class="noindentt">Show that the statement</p>
<p class="image"><i>j</i> = 2<i>i</i></p>
<p class="noindent">is an invariant for this <code>while</code>-loop.</p>
<p class="noindentta"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;Let <i>i</i> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-1.png" width="10" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-1.png"> and = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-2.png" width="13" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-2.png"> before the segment</p>
<p class="loweralpha1-le"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="loweralpha1-le"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 2</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_365"></span>executes, and let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-1.png" width="11" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-1.png"> and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-2.png" width="13" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-2.png"> denote the values of <i>i</i> and <i>j</i> after execution. To prove that <i>j</i> = 2<i>i</i> is an invariant, we need to show that</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis365-1.png" alt="Image" width="197" height="38" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis365-1.png"></p>
<p class="noindent">The first assignment statement is the only statement that changes the value of <i>i</i>. Therefore,</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis365-2.png" alt="Image" width="103" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis365-2.png"></p>
<p class="noindent">or equivalently, <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-1.png" width="10" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-1.png"> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-1.png" width="11" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-1.png"> − 1. Similarly, <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-2.png" width="13" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-2.png"> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-2.png" width="13" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-2.png"> + 2. Suppose <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-2.png" width="13" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-2.png"> = 2<img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-1.png" alt="Image" width="10" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-1.png">. Then</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis365-3.png" alt="Image" width="179" height="154" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis365-3.png"></p>
<p class="noindent">as required.</p>
<p class="right1">□</p>
<p class="indentt">We have proved—rather formally—a fact that we could have easily checked informally. Notice that if you trace through this algorithm, the values of <i>i</i> and <i>j</i> are as follows.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis365-4.png" alt="Image" width="317" height="80" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis365-4.png"></p>
<p class="noindent">It seems clear that <i>j</i> is always twice as big as <i>i</i>. Certainly this is true before the loop executes: 0 = 2·0. We have proved that <i>j</i> = 2<i>i</i> is a loop invariant, so <i>j</i> = 2<i>i</i> remains true after the first iteration, and the second, and so on, until the loop terminates.</p>
<p class="indent">Notice that this is essentially an inductive argument. The base case involves checking that <i>j</i> = 2<i>i</i> before entering the loop. The proof that <i>j</i> = 2<i>i</i> is a loop invariant is the inductive step. Therefore, by induction, <i>j</i> = 2<i>i</i> after any number of loop iterations, so <i>j</i> = 2<i>i</i> is a postcondition on this algorithm.</p>
<p class="indent">When writing algorithms, it is good practice to include any known invariants in the code as comments, as in the next example. Note also that the following proof is written explicitly as an inductive argument.</p>
<p class="noindentt"><a id="ch5ex24"></a><b><span class="blue">Example 5.24</span></b> Prove the correctness of the following routine using the given loop invariant.</p>
<p class="noindentt">&nbsp;&nbsp;Preconditions: <i>m, n</i> ∈ <b>Z</b>, <i>m</i> ≥ 0, <i>n</i> &gt; 0.</p>
<p class="noindentt">&nbsp;&nbsp;Postconditions: <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-3.png" alt="Image" width="178" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-3.png"> mod <i>n</i>.</p>
<p class="mathet"><i>q</i> ← 0, <i>r</i> ← <i>m</i></p>
<p class="mathe"><code>// invariant</code>: <i>m</i> = <i>qn</i> + <i>r, r</i> ≥ 0</p>
<p class="mathe"><code>while</code> <i>r</i> ≥ <i>n</i> <code>do</code></p>
<p class="mathe2a"><i>q</i> ← <i>q</i> + 1</p>
<p class="mathe2a"><i>r</i> ← <i>r</i> − <i>n</i></p>
<p class="noindentt"><span epub:type="pagebreak" id="page_366"></span><b><span class="blue">Proof</span></b>&nbsp;&nbsp;We use induction on the number of times through the loop. Before the loop executes, <i>q</i> = 0 and <i>r</i> = <i>m</i>, so we check that <i>m</i> = 0 · <i>n</i>+<i>m</i>, which is true. Let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-1.png" width="14" height="26" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-1.png"> and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-2.png" width="14" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-2.png"> be the values of <i>q</i> and <i>r</i> before going through the loop, and suppose as inductive hypothesis that <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-3.png" width="123" height="29" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-3.png"> with <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-4.png" width="60" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-4.png">. After one more iteration,</p>
<p class="image1"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/eq366-1.png" alt="Image" width="576" height="79" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/eq366-1.png"></p>
<p class="noindent">and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-5.png" alt="Image" width="14" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-5.png"> ≥ 0, since <i>r</i> ≤ <i>n</i> was a condition of entering the loop. Therefore,</p>
<table class="table3">
<tbody><tr>
<td class="td-r"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-3.png" width="123" height="29" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-3.png"></td>
<td class="td-r">by inductive hypothesis</td>
</tr>
<tr>
<td class="td-r1"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-6.png" width="190" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-6.png"></td>
<td class="td-r">using Equations 5.6.1 and 5.6.2</td>
</tr>
<tr>
<td class="td-r1"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-7.png" width="95" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-7.png"></td>
<td class="td-r"></td>
</tr>
</tbody></table>
<p class="noindent">By induction, the invariant will be true after every iteration of the loop, and therefore, also at loop termination, when <i>r</i> &lt; <i>n</i>. So when the routine finishes, <i>m</i> = <i>qn</i> + <i>r</i> with 0 ≤ <i>r</i> &lt; <i>n</i>, which means that <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-8.png" alt="Image" width="102" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-8.png"> and <i>r</i> = <i>m</i> mod <i>n</i>.</p>
<p class="right1">□</p>
<p class="indentt">You might be wondering why, in the last proof, the variables <i>q</i> and <i>r</i> sometimes have lines above or below them, but the variables <i>m</i> and <i>n</i> do not. The answer points to a good rule of thumb: the loop changes the value of <i>q</i> and <i>r</i>, but the values of <i>m</i> and <i>n</i> remain constant during loop execution. Therefore we need to keep track of the before/after values of <i>q</i> and <i>r</i> with the underlines/overlines, but this notation is unnecessary for the fixed variables <i>m</i> and <i>n</i>.</p>
<p class="h2"><a id="ch5sub6sub2"></a><b>5.6.2&nbsp;&nbsp;&nbsp;Searching and Sorting</b></p>
<p class="noindent">In the last section we verified some recursive algorithms for searching and sorting. We now verify iterative versions using loop invariants.</p>
<p class="noindentt"><a id="ch5ex25"></a><b><span class="blue">Example 5.25</span></b> Consider the iterative binary search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>). The pseudocode routine inside the <code>while</code>-loop is as follows.</p>
<p class="mathet"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-9.png" alt="Image" width="148" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-9.png"></p>
<p class="mathe"><code>if</code> <i>t</i> &gt; <i>x<sub>i</sub></i> <code>then</code></p>
<p class="mathe1"><i>l</i> ← <i>i</i> + 1</p>
<p class="mathe"><code>else</code></p>
<p class="mathe1"><i>r</i> ← <i>i</i></p>
<p class="noindentt">Prove the following loop invariant for the <code>while</code>-loop.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis366-1.png" alt="Image" width="764" height="28" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis366-1.png"></p>
<p class="noindentt"><span epub:type="pagebreak" id="page_367"></span><b><span class="blue">Proof</span></b>&nbsp;&nbsp;Let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-1.png" width="10" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-1.png"> and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-2.png" width="14" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-2.png"> represent the values of <i>l</i> and <i>r</i> before the above pseudocode segment executes. Suppose that the invariant holds for these values of <i>l</i> and <i>r</i>; that is, suppose that</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis367-1.png" alt="Image" width="530" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis367-1.png"></p>
<p class="noindent">with 1 ≤ <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-1.png" width="10" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-1.png"> ≤ <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-2.png" width="14" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-2.png"> ≤ <i>n</i>. Set <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-10.png" width="159" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-10.png">, and note that this implies that <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-1.png" width="10" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-1.png"> ≤ <i>i</i> ≤ <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-2.png" width="14" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-2.png">. Suppose that <i>t</i> ∈ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …,<i>x<sub>n</sub></i>}, so by assumption, <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-3.png" width="220" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-3.png">. If <i>t</i> &gt; <i>x<sub>i</sub></i>, then <i>t</i> must be in the subset <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-4.png" width="204" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-4.png">, since the list is in order. In this case, the pseudocode segment sets <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-2.png" width="10" height="23" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-2.png"> = <i>i</i> + 1 (which is still less than <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in366-2.png" width="14" height="20" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in366-2.png">) and sets <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-5.png" width="61" height="26" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-5.png">. If <i>t</i> ≤ <i>x<sub>i</sub></i>, then <i>t</i> must be in the subset <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-6.png" width="178" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-6.png">, so the segment sets <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-7.png" width="52" height="32" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-7.png"> and <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-8.png" width="54" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-8.png">. In either case,</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis367-2.png" alt="Image" width="230" height="31" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis367-2.png"></p>
<p class="noindent">with <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in367-9.png" width="146" height="28" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in367-9.png"> as required.</p>
<p class="right1">□</p>
<p class="noindentt">This invariant expresses the fact that <i>t</i> remains in the set {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>} even as the values of <i>l</i> and <i>r</i> change. Once the invariant has been established, it is easy to prove the correctness of the algorithm.</p>
<p class="noindentta"><a id="ch5ex26"></a><b><span class="blue">Example 5.26</span></b> Use the above loop invariant to prove the correctness of the iterative binary search (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo3">Algorithm 5.3</a>).</p>
<p class="noindentta"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;Before the loop executes, <i>l</i> = 1 and <i>r</i> = <i>n</i>, so the loop invariant becomes</p>
<p class="image">(<i>t</i> ∈ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>n</i></sub>})⇒(<i>t</i> ∈ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>n</i></sub>}), with 1 ≤ 1 ≤ <i>n</i> ≤ <i>n</i>,</p>
<p class="noindent">which is true. Therefore, by induction, the invariant is true when the loop finishes. At loop termination, <i>l</i> = <i>r</i>, so the invariant implies that</p>
<p class="image">(<i>t</i> ∈ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>n</i></sub>})⇒(<i>t</i> ∈ {<i>x</i><sub><i>l</i></sub>}),</p>
<p class="noindent">which is equivalent to the postconditions.</p>
<p class="right1">□</p>
<p class="indentt">The loop invariant in this last proof was a sort of “postcondition in progress.” The binary search algorithm works by moving <i>l</i> and <i>r</i> closer together, all the while keeping the target in the set {<i>x<sub>l</sub>, x</i><sub><i>l</i>+1</sub>, …, <i>x<sub>r</sub></i>}. Once <i>l</i> = <i>r</i>, the postcondition in progress becomes the desired postcondition.</p>
<p class="indent">When a loop manipulates an array, a good loop invariant often makes a statement about the desired result for part of the array. For example, consider the following sorting algorithm.</p>
<span epub:type="pagebreak" id="page_368"></span>
<p class="linet"></p>
<p class="alg"><a id="ch5algo21"></a><b>Algorithm 5.21</b> Selection Sort.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: The elements of the array <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, <i>x</i><sub>3</sub>, …, <i>x<sub>n</sub></i> can be compared by ≤. In addition, <i>n</i> ≥ 1.</p>
<p class="hang3">Postconditions: <i>x</i><sub>1</sub> ≤ <i>x</i><sub>2</sub> ≤ <i>x</i><sub>3</sub> ≤ ··· ≤ <i>x<sub>n</sub></i>.</p>
<p class="mathet"><i>i</i> ← 1</p>
<p class="mathe"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <i>m</i> ← <i>i</i></p>
<p class="mathe2b"><i>j</i> ← <i>i</i> + 1</p>
<p class="mathe2b"><code>while</code> <i>j</i> ≤ <i>n</i> <code>do</code></p>
<p class="mathe2d"><span class="mat1">⌜</span> <code>if</code> <i>x</i><sub><i>j</i></sub> &lt; <i>x</i><sub><i>m</i></sub> <code>then</code></p>
<p class="mathe2e"><i>m</i> ← <i>j</i></p>
<p class="mathe2d"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2b"><code>swap</code> <i>x<sub>i</sub></i> <code>and</code> <i>x<sub>m</sub></i></p>
<p class="mathe2a"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="linetb"></p>
<p class="indent">The selection sort works by searching the list for the smallest element, putting it in front, then searching for the next smallest element, putting it in the next position, and so on. Since this process builds up the ordered list from left to right, a good invariant for the <code>while</code>-<i>i</i> loop is the statement that the first <i>i</i> elements are in order. But before we can prove anything about the <code>while</code>-<i>i</i> loop, we must first show that the <code>while</code>-<i>j</i> loop correctly locates the smallest element in the set {<i>x<sub>i</sub>, x</i><sub><i>i</i>+1</sub>, …, <i>x<sub>n</sub></i>}. This is also done with a loop invariant.</p>
<p class="noindentt"><a id="ch5lem2"></a><b>Lemma 5.2</b> Suppose 1 ≤ <i>i</i> &lt; <i>n</i>. The statement</p>
<p class="image"><i>x</i><sub><i>m</i></sub> = minimum{<i>x</i><sub><i>i</i></sub>, <i>x</i><sub><i>i</i>+1</sub>, …, <i>x</i><sub><i>j</i>−1</sub>}</p>
<p class="noindent">is an invariant for the loop in the following pseudocode segment.</p>
<p class="mathet"><i>m</i> ← <i>i</i></p>
<p class="mathe"><i>j</i> ← <i>i</i> + 1</p>
<p class="mathe"><code>while</code> <i>j</i> ≤ <i>n</i> <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <code>if</code> <i>x</i><sub><i>j</i></sub> &lt; <i>x</i><sub><i>m</i></sub> <code>then</code></p>
<p class="mathe2b"><i>m</i> ← <i>j</i></p>
<p class="mathe2"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="noindentt">Furthermore, when the loop terminates,</p>
<p class="image"><i>x</i><sub><i>m</i></sub> = minimum{<i>x</i><sub><i>i</i></sub>, <i>x</i><sub><i>i</i>+1</sub>, …, <i>x</i><sub><i>n</i></sub>}</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;Exercise.</p>
<p class="right">□</p>
<p class="indentt">We can now use this lemma to verify the selection sort algorithm.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_369"></span><a id="ch5ex27"></a><b><span class="blue">Example 5.27</span></b> Prove the correctness of the selection sort (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo21">Algorithm 5.21</a>).</p>
<p class="noindentt"><b><span class="blue">Proof</span></b>&nbsp;&nbsp;We begin by showing that the following statement is an invariant for the <code>while</code>-<i>i</i> loop in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo21">Algorithm 5.21</a>.</p>
<p class="blockquote">The smallest <i>i</i> − 1 elements of <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> are in order at the front of the list.<sup><a id="rch5fn6" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fn6" class="totri-footnote">6</a></sup></p>
<p class="noindent">Let <i>i</i> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-1.png" width="10" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-1.png">, and, for 1 ≤ <i>k</i> ≤ <i>n</i>, let <i>x<sub>k</sub></i> = <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-1.png" width="28" height="22" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-1.png"> before the following segment executes.</p>
<p class="mathet"><span class="mat1">⌜</span> <i>m</i> ← <i>i</i></p>
<p class="mathe1"><i>j</i> ← <i>i</i> + 1</p>
<p class="mathe1"><code>while</code> <i>j</i> ≤ <i>n</i> <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <code>if</code> <i>x</i><sub><i>j</i></sub> &lt; <i>x</i><sub><i>m</i></sub> <code>then</code></p>
<p class="mathe2d"><i>m</i> ← <i>j</i></p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 1</p>
<p class="mathe1"><code>swap</code> <i>x<sub>i</sub></i> <code>and</code> <i>x<sub>m</sub></i></p>
<p class="mathe"><span class="mat1">⌞</span>&nbsp;<i>i</i> ← <i>i</i> + 1</p>
<p class="noindentt">Suppose that the smallest <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in364-1.png" width="10" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in364-1.png"> − 1 elements of <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-2.png" width="148" height="22" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-2.png"> are in order at the front of the list. By <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5lem2">Lemma 5.2</a>, the segment finds <i>m</i> such that</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis369-2.png" alt="Image" width="380" height="35" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis369-2.png"></p>
<p class="noindent">Then the values of <i>x<sub>i</sub></i> and <i>x<sub>m</sub></i> are swapped, so <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-3.png" width="95" height="30" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-3.png">. Finally, <i>i</i> is incremented, <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-4.png" width="92" height="31" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-4.png">, which means that <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-5.png" width="112" height="28" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-5.png">.</p>
<p class="indent">Now the values of <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-6.png" width="161" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-6.png"> have not changed, so the smallest <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-1.png" width="11" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-1.png"> − 2 elements of <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-7.png" width="151" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-7.png"> are in order at the front of the list. Furthermore, <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-8.png" width="46" height="27" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-8.png"> is the next smallest element, since <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-9.png" width="32" height="22" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-9.png"> was chosen to be the minimum of the remaining elements. Therefore, the invariant holds: the smallest <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in365-1.png" width="11" height="24" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in365-1.png"> − 1 elements of <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in369-7.png" width="151" height="25" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in369-7.png"> are in order at the front of the list.</p>
<p class="indentt">To finish the proof of correctness, we need to show that the invariant holds before the loop begins, and then evaluate the invariant at loop termination. Before the loop begins, <i>i</i> = 1, so the invariant makes a claim about “the smallest 0 elements” of the list. Since this claim is true vacuously, there is nothing to prove. At loop termination <i>i</i> = <i>n</i>, so the loop invariant implies that</p>
<p class="image"><i>x</i><sub>1</sub> ≤ <i>x</i><sub>2</sub> ≤ … ≤ <i>x</i><sub><i>n</i>−1</sub></p>
<p class="noindent">and <i>x</i><sub><i>n</i>−1</sub> ≤ <i>x<sub>n</sub></i>, the only remaining element. This statement is equivalent to the postconditions, as required.</p>
<p class="right1">□</p>
<p class="h2"><a id="ch5sub6sub3"></a><span epub:type="pagebreak" id="page_370"></span><b>5.6.3&nbsp;&nbsp;&nbsp;Using Invariants to Design Algorithms</b></p>
<p class="noindent">Understanding loop invariants can help you think about how to write algorithms. As an illustration, consider the problem of finding a zero of a continuous function <i>f</i> (<i>x</i>), i.e., a point <i>x</i> where <i>f</i> (<i>x</i>) = 0.</p>
<p class="indent">Suppose that we start with two points <i>a</i> and <i>b, a</i> &lt; <i>b</i>, such that <i>f</i> (<i>x</i>) changes sign as <i>x</i> goes from <i>a</i> to <i>b</i>; that is, <i>f</i> (<i>a</i>) <i>f</i> (<i>b</i>) ≤ 0. Since <i>f</i> is continuous, this implies that <i>f</i> (<i>x</i>) has a zero in the interval [<i>a, b</i>]. We would like to close in on the zero of the function until we get within a certain desired accuracy. One approach would be to try to shrink the interval down in some systematic way, all the while making sure that the zero stays inside the interval. This last condition sounds like a loop invariant:</p>
<p class="noindentt">&nbsp;&nbsp;Invariant: <i>f</i> (<i>a</i>) <i>f</i> (<i>b</i>) ≤ 0.</p>
<p class="indentt">Now we need to decide on a way to shrink the interval down. Dividing it in half is probably the most straightforward thing to do. Thus, our algorithm will look something like this:</p>
<p class="mathet"><code>while (not done) do</code></p>
<p class="mathe1"><code>cut the interval in half</code></p>
<p class="indentt">The key is this: when we cut the interval in half, we need to maintain the loop invariant. If we halve the interval by taking the midpoint, we can make sure the new interval contains the zero of <i>f</i> by replacing the appropriate endpoint (<i>a</i> or <i>b</i>) with the midpoint. We choose which endpoint to replace by making sure <i>f</i> (<i>x</i>) changes signs over the new interval. If <i>ε</i> is some small error tolerance, we can repeat our loop until the interval has width <i>ε</i>. Thus, the result is shown in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo22">Algorithm 5.22</a>.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo22"></a><b>Algorithm 5.22</b> Finding a zero of a continuous function.</p>
<p class="lineb"></p>
<p class="hang3">Preconditions: <i>f</i> : <b>R</b> → <b>R</b> is a continuous function, with <i>f</i> (<i>a</i>) <i>f</i> (<i>b</i>) ≤ 0, and <i>ε</i> &gt; 0.</p>
<p class="hang3">Postconditions: <i>f</i> (<i>x</i>) = 0 for some <i>x</i> with | <i>x</i> − <i>a</i> | <i>&lt; ε</i> and | <i>x</i> − <i>b</i> | <i>&lt; ε</i>. (That is, <i>a</i> and <i>b</i> are both within <i>ε</i> of a zero of <i>f</i>.)</p>
<p class="mathet"><code>while</code> <i>b</i> − <i>a</i> ≥ ε <code>do</code></p>
<p class="mathe2"><span class="mat1">⌜</span> <i>m</i> ← (<i>a</i> + <i>b</i>)/2</p>
<p class="mathe2a"><code>if</code> <i>f</i> (<i>m</i>) <i>f</i> (<i>b</i>) ≤ 0 <code>then</code></p>
<p class="mathe2b"><i>a</i> ← <i>m</i></p>
<p class="mathe2a"><code>else</code></p>
<p class="mathe2"><span class="mat1">⌞</span>&nbsp;&nbsp;<i>b</i> ← <i>m</i></p>
<p class="linetb"></p>
<p class="indent">At loop termination, <i>f</i> (<i>a</i>) <i>f</i> (<i>b</i>) ≤ 0, because we have designed our loop so that the above invariant holds. Furthermore, the exit conditions for the loop ensure that <span epub:type="pagebreak" id="page_371"></span><i>b</i> − <i>a</i> &lt; <i>ε</i>. Thus, both <i>a</i> and <i>b</i> are within <i>ε</i> of the desired zero of <i>f</i> (<i>x</i>). <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5fig19">Figure 5.19</a> illustrates this procedure.</p>
<div class="cap">
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/fig371-1.png" alt="Image" width="643" height="506" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/fig371-1.png"></p>
<p class="figcaption"><a id="ch5fig19"></a><b><span class="blue">Figure 5.19</span></b> Finding a zero of a function by iteration.</p>
</div>
<p class="border"></p>
<p class="border1"></p>
<p class="h3"><a id="ch5exe6"></a>Exercises 5.6</p>
<p class="numlist">1.&nbsp;&nbsp;For the following line of pseudocode, let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-1.png" width="14" height="18" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-1.png"> denote the value of the variable <i>z</i> before execution, and let <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-2.png" width="14" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-2.png"> denote the value of <i>z</i> after execution.</p>
<p class="blockquote3">&nbsp;&nbsp;<i>z</i> ← 2<i>z</i> − 7</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Suppose that <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-1.png" width="14" height="18" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-1.png"> = 11. What is <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-2.png" width="14" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-2.png">?</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Suppose that <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-2.png" width="14" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-2.png"> = 3. What is <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-1.png" width="14" height="18" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-1.png">?</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Write an equation giving <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-2.png" width="14" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-2.png"> in terms of <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-1.png" width="14" height="18" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-1.png">.</p>
<p class="loweralpha1">(d)&nbsp;&nbsp;Write an equation giving <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-1.png" width="14" height="18" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-1.png"> in terms of <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in371-2.png" width="14" height="19" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in371-2.png">.</p>
<p class="numlist">2.&nbsp;&nbsp;Consider the following loop.</p>
<p class="mathe1t"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2b"><i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2a"><span class="mat1">⌞</span> <i>k</i> ← 10 · <i>k</i></p>
<p class="numlistpara1"><span epub:type="pagebreak" id="page_372"></span>Prove that each of the following statements is a loop invariant.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;<i>i</i> = <i>j</i></p>
<p class="loweralpha1">(b)&nbsp;&nbsp;<i>i</i> &lt; <i>j</i> + 10</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;<i>k</i> = 10<i><sup>i</sup></i></p>
<p class="numlist">3.&nbsp;&nbsp;Let <i>n</i> ∈ <b>N</b>. Consider the following algorithm. <i>i</i> ← 0</p>
<p class="mathe2t"><i>i</i> ← 0</p>
<p class="mathe2"><i>j</i> ← 0</p>
<p class="mathe2"><i>k</i> ← 1</p>
<p class="mathe2"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2d">&nbsp;<span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2e"><i>j</i> ← <i>j</i> + 1</p>
<p class="mathe2d">&nbsp;<span class="mat1">⌞</span> <i>k</i> ← 10 · <i>k</i></p>
<p class="numlistpara1">Use appropriate loop invariants from Exercise 2 to prove that each of the following statements is true after the algorithm executes.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;<i>i</i> = <i>j</i> = <i>n</i></p>
<p class="loweralpha1">(b)&nbsp;&nbsp;<i>k</i> = 10<i><sup>n</sup></i></p>
<p class="numlist">4.&nbsp;&nbsp;Show that the statement</p>
<p class="blockquote3">&nbsp;&nbsp;<i>m</i> ≥ <i>x</i> for all <i>x</i> ∈ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub>i</sub>}</p>
<p class="numlistpara1">is a loop invariant for the loop in the following pseudocode segment.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i>} ⊆ <b>Z</b></p>
<p class="mathe2t"><i>i</i> ← 1</p>
<p class="mathe2"><i>m</i> ← <i>x</i><sub>1</sub></p>
<p class="mathe2"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2c"><code>if</code> <i>x</i><sub><i>i</i></sub> &gt; <i>m</i> <code>then</code></p>
<p class="mathe2b"><span class="mat1">⌞</span>&nbsp;&nbsp;<i>m</i> ← <i>x</i><sub><i>i</i></sub></p>
<p class="numlist">5.&nbsp;&nbsp;Use the invariant in Exercise 4 to give a postcondition on the algorithm.</p>
<p class="numlist">6.&nbsp;&nbsp;In <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5sub2">Section 5.2</a>, we made the claim that the algorithm</p>
<p class="mathe2t"><code>for</code> <i>i</i> ∈ {1,2, …, <i>n</i>} <code>do</code></p>
<p class="mathe2a">&nbsp;<code>visit</code> <i>x<sub>i</sub></i></p>
<p class="numlistpara1">visits each element in the array <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x<sub>n</sub></i> exactly once. Prove this claim formally using a loop invariant. (Hint: First, rewrite the algorithm using a <code>while</code>-loop instead of a <code>for</code>-loop.)</p>
<p class="numlist"><span epub:type="pagebreak" id="page_373"></span>7.&nbsp;&nbsp;Use a loop invariant to prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> is an odd natural number.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/in373-1.png" width="157" height="65" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/in373-1.png"></p>
<p class="mathe2t"><i>s</i> ← 1</p>
<p class="mathe2"><i>i</i> ← 1</p>
<p class="mathe2"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 2</p>
<p class="mathe2a"><span class="mat1">⌞</span> <i>s</i> ← <i>s</i> + <i>i</i></p>
<p class="numlist">8.&nbsp;&nbsp;Use a loop invariant to prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ∈ <b>N</b></p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <i>x</i> = <i>n</i>!</p>
<p class="mathe2t"><i>x</i> ← 1</p>
<p class="mathe2"><i>i</i> ← 1</p>
<p class="mathe2"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>x</i> ← <i>x</i> · <i>i</i></p>
<p class="numlist">9.&nbsp;&nbsp;Consider the following algorithm.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>N</i> is an even natural number.</p>
<p class="mathe2t"><i>i</i> ← <i>N</i></p>
<p class="mathe2"><i>x</i> ← <i>N</i></p>
<p class="mathe2"><i>y</i> ← 0</p>
<p class="mathe2"><code>while</code> <i>i</i> &gt; 0 <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> − 2</p>
<p class="mathe2c"><i>x</i> ← <i>x</i> − 1</p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>y</i> ← <i>y</i> + 1</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Prove that the conjunction of statements</p>
<p class="image"><i>x</i> + <i>y</i> = <i>N</i> ∧ <i>x</i> − <i>y</i> = <i>i</i></p>
<p class="loweralphapara2n">is an invariant for the <code>while</code>-loop.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Use the invariant to prove the correctness of a good postcondition on this algorithm.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Suppose that <i>N</i> = 300 before the algorithm begins. What is the value of <i>x</i> when the algorithm terminates?</p>
<p class="numlistm"><span epub:type="pagebreak" id="page_374"></span>10.&nbsp;&nbsp;Consider the following algorithm.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>n</i> ∈ <b>Z</b>.</p>
<p class="mathe2at"><i>i</i> ← 0</p>
<p class="mathe2a"><i>j</i> ← 0</p>
<p class="mathe2a"><code>while</code> <i>i</i> &lt; <i>n</i><sup>2</sup> <code>do</code></p>
<p class="mathe2c"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="mathe2c"><span class="mat1">⌞</span> <i>j</i> ← <i>j</i> + 2<i>i</i></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Prove that the statement <i>j</i> = <i>i</i><sup>2</sup> + <i>i</i> is an invariant for the <code>while</code>-loop.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Use the invariant to find a postcondition on this algorithm that gives the value of <i>j</i> in terms of <i>n</i>.</p>
<p class="numlistm">11.&nbsp;&nbsp;Consider the iterative sequential search of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo1">Algorithm 5.1</a>.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Prove that the statement</p>
<p class="image"><i>t</i> ∉ {<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>i</i>–1</sub>}</p>
<p class="loweralphapara2n">is an invariant for the <code>while</code>-loop in this algorithm. (Interpret this statement as “<i>t</i> ∉ <span class="a1">∅</span>” when <i>i</i> = 1.)</p>
<p class="loweralpha1t">(b)&nbsp;&nbsp;Suppose that <i>i</i> = <i>n</i>+1 at loop termination. What can you conclude from this loop invariant?</p>
<p class="numlistm">12.&nbsp;&nbsp;Recall (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/09_Chapter03.xhtml#ch3def1">Definition 3.1</a>) that the Fibonacci numbers are defined by the following recurrence relation.</p>
<p class="image"><img src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/dis374-3.png" alt="Image" width="583" height="71" data-mfp-src="/library/view/essentials-of-discrete/9781284056242/images/dis374-3.png"></p>
<p class="numlistpara1">The following algorithm computes <i>F</i>(<i>n</i>), the <i>n</i>th Fibonacci number.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo23"></a><b>Algorithm 5.23</b> Computing <i>F</i>(<i>n</i>) iteratively.</p>
<p class="lineb"></p>
<p class="noindentt">&nbsp;&nbsp;Preconditions: <i>n</i> ∈ <b>N</b> and <i>n</i> ≥ 2.</p>
<p class="noindent">&nbsp;&nbsp;Postconditions: <i>x</i> = <i>F</i>(<i>n</i>)</p>
<p class="mathet"><i>x</i> ← 1</p>
<p class="mathe"><i>y</i> ← 1</p>
<p class="mathe"><i>i</i> ← 2</p>
<p class="mathe"><code>while</code> <i>i</i> &lt; <i>n</i> <code>do</code></p>
<p class="mathe2a"><span class="mat1">⌜</span> <i>t</i> ← <i>x</i></p>
<p class="mathe2b"><i>x</i> ← <i>x</i> + <i>y</i></p>
<p class="mathe2b"><i>y</i> ← <i>t</i></p>
<p class="mathe2a"><span class="mat1">⌞</span> <i>i</i> ← <i>i</i> + 1</p>
<p class="linetb"></p>
<p class="loweralpha1t"><span epub:type="pagebreak" id="page_375"></span>(a)&nbsp;&nbsp;Prove that the statement</p>
<p class="image"><i>x</i> = <i>F</i>(<i>i</i>) and <i>y</i> = <i>F</i>(<i>i</i> − 1)</p>
<p class="loweralphapara2n">is an invariant for the <code>while</code>-loop.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Prove that the algorithm is correct.</p>
<p class="numlistm">13.&nbsp;&nbsp;Consider the following recursive algorithm for computing the <i>n</i>th Fibonacci number.</p>
<p class="linet"></p>
<p class="alg"><a id="ch5algo24"></a><b>Algorithm 5.24</b> Computing <i>F</i>(<i>n</i>) recursively.</p>
<p class="lineb"></p>
<p class="noindent">&nbsp;&nbsp;Preconditions: <i>n</i> ∈ <b>N</b> and <i>n</i> ≥ 1.</p>
<p class="noindent">&nbsp;&nbsp;Postconditions: <i>x</i> = <i>F</i>(<i>n</i>)</p>
<p class="mathet"><code>function FibNum</code>(<i>n</i> ∈ <i>N</i>)</p>
<p class="mathe1"><code>if</code> (<i>n</i> = 1) ∨ (<i>n</i> = 2) <code>then</code></p>
<p class="mathe2"><code>return</code> 1</p>
<p class="mathe1"><code>else</code></p>
<p class="mathe2"><code>return Fibnum</code>(<i>n</i> − 1) + <code>FibNum</code>(<i>n</i> − 2)</p>
<p class="linetb"></p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;Use a recurrence relation to compute (in terms of <i>n</i>) the number of “+” operations performed by <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo24">Algorithm 5.24</a>.</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Compute (in terms of <i>n</i>) the number of “+” operations performed by the iterative <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo23">Algorithm 5.23</a>.</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Which algorithm is more efficient?</p>
<p class="numlist1bt">*14.&nbsp;&nbsp;Consider the merge subroutine of <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo11">Algorithm 5.11</a>. The goal of this exercise is to prove that this algorithm is correct.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;State an appropriate loop invariant. (Hint: It will be similar to [but not the same as] the invariant used to verify the selection sort in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5ex27">Example 5.27</a>.)</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;Prove that your proposed statement is a loop invariant. (Hint: Your proof can [and should] make use of the preconditions of the algorithm.)</p>
<p class="loweralpha1">(c)&nbsp;&nbsp;Prove that the <code>Merge</code> algorithm is correct.</p>
<p class="numlist1bt">*15.&nbsp;&nbsp;Use a loop invariant to prove the correctness of the bubble sort (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo2">Algorithm 5.2</a>).</p>
<p class="numlistm">16.&nbsp;&nbsp;Use an invariant to show that Prim’s algorithm (5.9) always produces a tree.</p>
<p class="numlistm">17.&nbsp;&nbsp;Use a loop invariant to prove that the following algorithm is correct.</p>
<p class="numlistpara1">&nbsp;&nbsp;Preconditions: <i>f</i> (<i>x</i>) = <i>a</i><sub>0</sub> + <i>a</i><sub>1</sub><i>x</i> + <i>a</i><sub>2</sub><i>x</i><sup>2</sup> + ··· + <i>a<sub>n</sub>x<sup>n</sup>, t</i> ∈ <b>R</b>.</p>
<p class="numlistpara1">&nbsp;&nbsp;Postconditions: <i>y</i> = <i>f</i> (<i>t</i>).</p>
<p class="mathe2t"><span epub:type="pagebreak" id="page_376"></span><i>y</i> ← <i>a</i><sub><i>n</i></sub></p>
<p class="mathe2"><i>i</i> ← <i>n</i></p>
<p class="mathe2"><code>while</code> <i>i</i> &gt; 0 <code>do</code></p>
<p class="mathe2b"><span class="mat1">⌜</span> <i>i</i> ← <i>i</i> − 1</p>
<p class="mathe2b"><span class="mat1">⌞</span> <i>y</i> ← <i>a<sub>i</sub></i> + <i>yt</i></p>
<p class="numlistm">18.&nbsp;&nbsp;Trace through the selection sort (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo21">Algorithm 5.21</a>) for <i>n</i> = 4 given initial values <i>x</i><sub>1</sub> = 5, <i>x</i><sub>2</sub> = 2, <i>x</i><sub>3</sub> = 7, and <i>x</i><sub>4</sub> = 1.</p>
<p class="numlistm">19.&nbsp;&nbsp;Approximate the complexity of the selection sort (<a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo21">Algorithm 5.21</a>).</p>
<p class="numlistm">20.&nbsp;&nbsp;Prove <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5lem2">Lemma 5.2</a>.</p>
<p class="numlistm">21.&nbsp;&nbsp;Trace <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo22">Algorithm 5.22</a> given initial values <i>a</i> = 1, <i>b</i> = 5, <i>ε</i> = 0.7, and <i>f</i> (<i>x</i>) = sin <i>x</i>. (Make sure your calculator is in radians.)</p>
<p class="numlistm">22.&nbsp;&nbsp;Suppose <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo22">Algorithm 5.22</a> is used with <i>f</i> (<i>x</i>) = <i>x</i><sup>2</sup> − 2 for initial values <i>a</i> = 1, <i>b</i> = 2, and <i>ε</i> = 0.00001.</p>
<p class="loweralpha1t">(a)&nbsp;&nbsp;What is the value of <i>a</i>, approximately, at loop termination?</p>
<p class="loweralpha1">(b)&nbsp;&nbsp;How many iterations does the loop perform?</p>
<p class="numlistm">23.&nbsp;&nbsp;Prove, formally, that the statement</p>
<p class="image"><i>f</i> (<i>a</i>) <i>f</i> (<i>b</i>) ≤ 0</p>
<p class="numlistpara1">is an invariant for the loop in <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#ch5algo22">Algorithm 5.22</a>.</p>
<p class="fline"></p>
<p class="footnote"><a id="ch5fn1" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#rch5fn1" class="totri-footnote">1</a>. The third of these comparisons is redundant, but we’ll ignore this inefficiency.</p>
<p class="footnote"><a id="ch5fn2" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#rch5fn2" class="totri-footnote">2</a>. Again, we omit the proof that this formula holds for all <i>n</i>, not just powers of 2.</p>
<p class="footnote"><a id="ch5fn3" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#rch5fn3" class="totri-footnote">3</a>. Recall that the height of a binary tree is the number of edges in the longest path from the root to a leaf. So a tree of height <i>p</i> represents a sequence of at most <i>p</i> decisions.</p>
<p class="footnote"><a id="ch5fn4" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#rch5fn4" class="totri-footnote">4</a>. The “<i>N</i>” in <i>NP</i> stands for “nondeterministic.” If you guess randomly (not in some determined order) and you happen to guess correctly, you can prove that your solution is right in polynomial time.</p>
<p class="footnote"><a id="ch5fn5" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#rch5fn5" class="totri-footnote">5</a>. The Riemann Hypothesis is probably the closest rival. Two famous results, Fermat’s Last Theorem and the Poincaré Conjecture, have only recently been proved.</p>
<p class="footnote"><a id="ch5fn6" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#rch5fn6" class="totri-footnote">6</a>. More formally, this invariant says that <i>x</i><sub>1</sub> ≤ <i>x</i><sub>2</sub> ≤ · · · ≤ <i>x</i><sub><i>i</i>−1</sub>, and <i>x</i><sub><i>i</i>−1</sub> ≤ <i>x<sub>k</sub></i> for <i>i</i> ≤ <i>k</i> ≤ <i>n</i>, where the case <i>i</i> = 1 is vacuous; the invariant makes no claims about the list when <i>i</i> = 1.</p>
<div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-7" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders">
		
		<li class="copy"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#">Copy</a></li>
		
		<li class="add-highlight"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#">Add Highlight</a></li>
		<li class="add-note"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#">
			Add Note
		</a></li>
		
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/10_Chapter04.xhtml" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 4 Quantitative Thinking</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 6 Thinking Through Applications</div>
        </a>
    
  
  </div>

</section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    



        
      </div>
      




  <footer class="pagefoot t-pagefoot">
    <a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" class="icon-up" style="display: none;"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://learning.oreilly.com/r/">Recommended</a></li>
      
      <li>
      <a class="t-queue-footer" href="https://learning.oreilly.com/playlists/">Playlists</a>
      </li>
      
        <li><a class="t-recent-footer" href="https://learning.oreilly.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://learning.oreilly.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://learning.oreilly.com/u/preferences/">Settings</a></li>
      <li class="full-support"><a href="https://www.oreilly.com/online-learning/support/">Support</a></li>
      <li><a href="https://www.oreilly.com/online-learning/apps.html">Get the App</a></li>
      <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2019 <a href="https://learning.oreilly.com/" target="_blank">Safari</a>.</span>
    <a href="https://learning.oreilly.com/terms/">Terms of Service</a> /
    <a href="https://www.oreilly.com/privacy.html">Privacy Policy</a>
  </footer>

<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"transactionName":"YgdaZ0NSW0cEB0RdWltNfkZfUEFdCgofXFBHDVYdR1pQQxZeRl1QQj1aWkU=","errorBeacon":"bam.nr-data.net","licenseKey":"510f1a6865","queueTime":0,"beacon":"bam.nr-data.net","agent":"","applicationID":"3275661,67267027,67267028","applicationTime":187}</script>


    
    <script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/saved_resource" charset="utf-8"></script>
    <script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/saved_resource(1)" charset="utf-8"></script>
  

<script type="text/javascript" id="">(function(){window.medalliaUserIdentifier=document.documentElement.dataset.userUuid;window.medalliaUserName=document.documentElement.dataset.username})();</script>
<script type="text/javascript" id="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/embed.js"></script><script type="text/javascript" id="">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","https://connect.facebook.net/en_US/fbevents.js");fbq("init","1732687426968531");fbq("track","PageView");</script>
<noscript><img height="1" width="1" style="display:none" src="https://www.facebook.com/tr?id=1732687426968531&amp;ev=PageView&amp;noscript=1"></noscript><div class="annotator-notice">Sorry we could not read the annotations from the store</div><div class="font-flyout" style="top: 200.987px; left: 1343px;"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="https://learning.oreilly.com/library/view/essentials-of-discrete/9781284056242/xhtml/12_Chapter06.xhtml#">Reset</a>
</div>
</div><div style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.4175070734226962"><img style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.6076616829904784" width="0" height="0" alt="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/0"></div>


<script src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/saved_resource(2)" type="text/javascript"></script><script type="text/javascript" async="" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/generic1555505737076.js" charset="UTF-8"></script><div style="display: none; visibility: hidden;"><script>(function(){if(null!==document.querySelector('iframe[title\x3d"fb:share_button Facebook Social Plugin"]')&&void 0!==document.querySelector('iframe[title\x3d"fb:share_button Facebook Social Plugin"]')){var a=!1;window.addEventListener("blur",function(){a&&dataLayer.push({event:"eventTracker",eventCat:"social",eventAct:"share",eventLbl:"facebook",eventVal:0,nonInteraction:0})});document.querySelector('iframe[title\x3d"fb:share_button Facebook Social Plugin"]').addEventListener("mouseover",function(){window.focus();
a=!0});document.querySelector('iframe[title\x3d"fb:share_button Facebook Social Plugin"]').addEventListener("mouseout",function(){a=!1})}try{window.twttr=function(b,a,d){var c,e=b.getElementsByTagName(a)[0];if(!b.getElementById(d))return b=b.createElement(a),b.id=d,b.src="//platform.twitter.com/widgets.js",e.parentNode.insertBefore(b,e),window.twttr||(c={_e:[],ready:function(a){c._e.push(a)}})}(document,"script","twitter-wjs"),twttr.ready(function(a){a.events.bind("tweet",trackTwitter)})}catch(b){}})();
null!==document.querySelector(".IN-widget")&&void 0!==document.querySelector(".IN-widget")&&document.querySelector(".IN-widget").addEventListener("click",function(){dataLayer.push({event:"eventTracker",eventCat:"social",eventAct:"share",eventLbl:"linkedin",eventVal:0,nonInteraction:0})});
function trackTwitter(a){a&&(a.target&&"IFRAME"==a.target.nodeName&&(opt_target=extractParamFromUri(a.target.src,"url")),dataLayer.push({event:"eventTracker",eventCat:"social",eventAct:"share",eventLbl:"twitter",eventVal:0,nonInteraction:0}))}function extractParamFromUri(a,b){if(a){var c=new RegExp("[\\?\x26#]"+b+"\x3d([^\x26#]*)");c=c.exec(a);if(null!=c)return unescape(c[1])}};</script></div><span><div id="KampyleAnimationContainer" style="z-index: 2147483000; border: 0px; position: fixed; display: block; width: 0px; height: 0px;"></div></span><iframe scrolling="no" frameborder="0" allowtransparency="true" src="./Chapter 5 Analytical Thinking - Essentials of Discrete Mathematics, 3rd Edition_files/widget_iframe.2e9f365dae390394eb8d923cba8c5b11.html" title="Twitter settings iframe" style="display: none;"></iframe></body></html>